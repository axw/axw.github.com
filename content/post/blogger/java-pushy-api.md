+++
title = "Java Pushy API"
date = 2011-02-10T20:42:00Z
updated = 2011-02-10T20:42:03Z
tags = ["java", "pushy"]
blogimport = true 
aliases = [

  "/2011/02/java-pushy-api.html",

]
[author]
	name = "Andrew Wilkins"
	uri = "https://plus.google.com/102738380796586573408"
+++

It's been some time since I've spruiked Pushy, so here we go.&nbsp;One of my colleagues was talking the other day about how he had implemented a <a href="http://nc110.sourceforge.net/">netcat</a>-like service for <a href="http://staf.sourceforge.net/">STAF</a>, an automation framework aimed at testing. This got me thinking about how this could be done relatively easily, using the <i>pushy.net</i>&nbsp;package, something I haven't written about much, primarily because it's still a work in progress.<br /><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Back in version 0.3, I introduced a Java API to Pushy, as I mentioned in an&nbsp;<a href="http://axwalk.blogspot.com/2010/07/java-to-python.html">earlier post</a>. I briefly mentioned the incorporation of packages which mimic, and in many cases are interface compatible with, packages in the Java standard library such as <i>java.io</i> and <i>java.net</i>.</div><div><br /></div><div>The <i>pushy.net</i>&nbsp;package currently contains three main classes:</div><div><ul><li>RemoteInetSocketAddress (extends java.net.InetSocketAddress)</li><li>RemoteSocket (extends java.net.Socket), and</li><li>RemoteServerSocket (extends java.net.ServerSocket).</li></ul><div>RemoteInetSocketAddress simply provides a means of creating an InetSocketAddress whose address is resolved at the remote host. RemoteSocket is a wrapper around a remote Python socket object, but extends java.net.Socket&nbsp;to provide a familiar interface to Java developers. Similarly, RemoteServerSocket extends java.net.ServerSocket, and wraps a remote Python socket object.</div><div><br /></div><div>So how about netcat emulation? Well, I won't cover the whole implementation of a netcat clone, as that would be a non-trivial undertaking. But I will show you one of the fundamental requirements: to bind a server socket, accept a client connection, and print out the data received from that client.</div></div><div><br /></div><div><b>Step 1.&nbsp;Bind a socket, and listen for connections.</b><br /><br /><pre class="brush:java">import java.net.ServerSocket;<br />import java.net.Socket;<br />import pushy.Client;<br /><br />public class Test {<br />    public static void main(String[] args) throws Exception {<br />        Client conn = new Client("local:");<br />        try {<br />            ServerSocket server = new pushy.net.RemoteServerSocket(conn, 0);<br />            try {<br />            } finally {<br />                server.close();<br />            }<br />        } finally {<br />            conn.close();<br />        }<br />    }<br />}<br /></pre><br />In this code snippet, we're creating a RemoteServerSocket, and assigning it to a java.net.ServerSocket, to illustrate interface compatibility. The first argument to the constructor is the <i>pushy.Client</i> object we previously created, and the second argument is the port to bind to. Specifying a port of zero, means that we want to bind to an ephemeral port.<br /><br />The creation of the RemoteServerSocket involves creating a Python socket object on the remote host, and performing the <i>bind</i> and <i>listen</i> methods on it.<br /><br /><b>Step 2. Accept a client connection.</b><br /><br /><pre class="brush:java">Socket client = server.accept();<br />try {<br />} finally {<br />    client.close();<br />}<br /></pre><br />Here we can see that accepting a client connection is exactly as we would do with a standard java.net.ServerSocket. This probably isn't surprising, since we've upcasted our RemoteServerSocket to a plain old ServerSocket. One thing of interest here is that the Server object returned is in fact a RemoteServerSocket, wrapping a remote Python socket object.<br /><br /><b>Step 3. Read data from the client connection.</b><br /><br /><pre class="brush:java">InputStream in = client.getInputStream();<br />byte[] buf = new byte[1024];<br />int nread = in.read(buf, 0, buf.length);<br />while (nread != -1) {<br />    System.out.write(buf, 0, nread);<br />    System.out.flush();<br />    nread = in.read(buf, 0, buf.length);<br />}<br /></pre><br />Et voila! We can read the remote socket's output via a java.io.InputStream object, returned by the <i>getInputStream</i> method, which is overridden by RemoteSocket. One thing you may have noticed: to run this all on the local host, sans Pushy, you could substitute the right-hand side of the initial ServerSocket construction with a standard ServerSocket, and the rest of the code would remain unchanged.<br /><br />There are a few defects in the 0.3 release related to the pushy.net package, which will prevent these examples from working. I have rectified them in the process of writing this post. If you grab the trunk, it should all work nicely. There is <a href="https://bugs.launchpad.net/pushy/+bug/716393">one defect remaining</a>: the InputStream returned by RemoteSocket is based on a a file returned by Python's <i>socket.makefile</i> method. This differs from the InputStream returned by Java's standard Socket, in that a request for N bytes will not return until all N bytes, or EOF, are received. I hope to have this fixed in the coming days.<br /><br /></div>
