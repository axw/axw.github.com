+++
title = "First Post"
date = 2010-06-30T15:39:00Z
updated = 2010-06-30T15:39:43Z
tags = ["pushy python java"]
blogimport = true 
aliases = [

  "/2010/06/first-post.html",

]
[author]
	name = "Andrew Wilkins"
	uri = "https://plus.google.com/102738380796586573408"
+++

Woohoo!<br /><br />On a more serious note... if anyone stumbles across this page, I will be using it for discussing my project <a href="http://launchpad.net/pushy">Pushy</a>. Pushy is a Python (now Java too) package for connecting to a remote Python interpreter, and accessing objects therein as if they were local. In other words, it's a sort of RPC package.<br /><br />So why another RPC package? While I was working on test automation, I identified a couple of things I didn't like about existing RPC frameworks:<br /><ol><li>Invariably, a nailed-up (i.e. runs for an extended period of time) server is required to be running for you to connect to. This leads to the problem #2.</li><li>Custom software needs to be maintained on both the client and the server.</li><li>The security mechanisms in existing frameworks have a tendency to suck. For nailed-up servers running as an arbitrary user, the server program must perform its own authentication/authorisation to ensure the user can't access resources it isn't supposed to.</li></ol><div>My thinking was this: rather than implementing RPC services and maintaining them on all of these different servers, why can't I put all of the logic in the client? The <a href="http://docs.python.org/library/index.html">Python Standard Library</a>&nbsp;is rather extensive, why don't we just expose that to the client, and let the client define the "service"?&nbsp;That's the basis of Pushy.</div><div><br /></div><div>So first I started hacking away to develop a proof of concept, using XML-RPC to transparently access objects in a remote interpreter, automatically creating proxy objects to represent remote objects and performing method/operator calls by sending requests. Then I found <a href="http://rpyc.wikidot.com/">RPyC</a>, which did essentially the same thing, only better.&nbsp;</div><div><br /></div><div>So at this stage I've moved the "service" from server to client, but I still need to run some code on the server, and it's still "nailed-up". What's more, is that the server is running as a single user, which poses a massive security risk. How can we do better? Enter SSH...&nbsp;SSH is prevalent on Linux and UNIX operating systems, and one of the cool things you do with it is remotely execute a command and pipe to/from its standard I/O. Maybe we could do something with that?</div><div><br /></div><div>Using SSH solves all three problems, in fact. Pushy works as follows: the client application imports the Pushy package, and invokes a function to "connect" to a remote host. What this does is creates an SSH connection to the remote host, using the username and password (or public-key encryption) specified by the caller. After the connection is created, Pushy executes Python in the remote system, passing it a command-line program. i.e. Something like "python -c 'run_server()'". This command-line program is a short one, which reads a larger program off its standard input stream, and executes it to start the Pushy server program. The program didn't exist on disk before the connection, and won't exist after.</div><div><br /></div><div>So let's revisit the three problems now:</div><div><ol><li><i>(Problem: a nailed-up server is required.)</i> Unless you count <i>sshd</i>, no nailed-up services are required on the server. I think it's fair to discount sshd, as it is so commonplace.</li><li><i>(Problem: custom software must be maintained on both client and server.)</i>&nbsp;As described in the paragraph above, there is no longer any custom server code required to be maintained on the server. So we can implement programs to access arbitrary portions of the Python Standard Library on a remote system, with nary a change on the server. There is an added benefit here: if the client/server protocol changes, there's still nothing to upgrade on the server.</li><li><i>(Problem: server code must perform application-level authentication/authorisation.)</i>&nbsp;Did I mention I'm lazy? Doing authentication/authorisation properly is a pain in the neck, and I'd like to avoid it if I can. Turns out I can if I'm using SSH, as the "server" program is running as the user specified by the client program. Usual operating system authentication and access controls ensues.</li></ol></div><div><br /></div><div>Over time I decided to drop RPyC in favour of a writing my own protocol. I was using RPyC for things it wasn't intended and it showed in various areas, such as exception handling. One thing remains though: the auto-importing feature of RPyC is lovingly imitated by Pushy.</div><ul></ul>
