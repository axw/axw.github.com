+++
title = "C++ Source-to-Source Translation"
date = 2011-10-07T12:01:00Z
updated = 2011-10-07T12:03:50Z
blogimport = true 
aliases = [

  "/2011/10/c-source-to-source-translation.html",

]
[author]
	name = "Andrew Wilkins"
	uri = "https://plus.google.com/102738380796586573408"
+++

I've been on annual leave this week, so I've taken the opportunity to do some work on <a href="http://github.com/axw/cmonster">cmonster</a>. I've added preliminary support for source-to-source translation by introducing a wrapper for Clang's "Rewriter" API. My fingers have been moving furiously so it's all a bit rough, but it does work.<br /><br />The API flow is:<br /><br /><ol><li>Parse translation unit, returning an Abstract Syntax Tree (AST).</li><li>Walk AST to find bits of interest.</li><li>Insert/replace/erase text in the original source, using the location stored in each declaration/statement/token.</li></ol><div><b><span class="Apple-style-span" style="font-size: large;"><br /></span></b></div><div><b><span class="Apple-style-span" style="font-size: large;">Motivating Example</span></b></div><div><b><br /></b></div><div>Logging is a necessary evil in complex software, especially when said software is running on a customer's system, inaccessible to you. To make problem determination easier, we want a decent amount of information: file names, line numbers, function names, time of day, thread ID, ... but all of this comes at a cost. I'm not talking just cost in terms of CPU usage, though that is a major concern. I'm talking cost in terms of source code quality and maintainability.</div><div><br /></div><div>We'll start off with a trivial C program:</div><div><br /></div><div><pre class="prettyprint lang-c">int main(int argc, const char *argv[])<br />{<br />    if (argc % 2 == 0)<br />    {<br />        return 1;<br />    }<br />    else<br />    {<br />        return 0;<br />    }<br />}<br /></pre></div><div><br /></div><div>Let's say our needs are fairly humble: we just want to log the entry and exit of this function. Logging entry is easy: add a blob of code at the top of the function. We can get the function name and line number using __func__ (C99, C++11) and __LINE__. What about __func__ in C89? C++98? There's various alternatives, but some compilers have nothing. And that makes writing a cross-platform logging library a big old <a href="http://en.wikipedia.org/wiki/Pain_in_the_ass">PITA</a>.&nbsp;The information is there in the source code - if only we could get at it! In the end, we're more likely to forego <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>, and just reproduce the function name as a string literal.</div><div><br /></div><div>Getting the function name and line number isn't a huge problem, but how about adding function exit logging? Now we're going to have to insert a little bit of code before our return statements. So we'll have something like:</div><div><br /></div><div><pre class="prettyprint lang-c">int main(int argc, const char *argv[])<br />{<br />    const char *function = "main";<br />    printf("Entering %s:%s:%d\n", function,<br />           __FILE__, __LINE__);<br />    if (argc % 2 == 0)<br />    {<br />        printf("Leaving %s:%s:%d\n", function,<br />               __FILE__, __LINE__);<br />        return 1;<br />    }<br />    else<br />    {<br />        printf("Leaving %s:%s:%d\n", function,<br />               __FILE__, __LINE__);<br />        return 0;<br />    }<br />    return 0;<br />}<br /></pre></div><div><b><br /></b></div><div>Ugh. And that's just the start. It gets much nastier when we need to turn logging on/off at runtime, filter by function name, etc. We could make it much nicer with a variadic macro. Something like LOG(format...), which calls a varargs function with the 'function' variable, __FILE__, __LINE__ and the format and arguments you specify. Unfortunately variadic macros are not supported by some older compilers. The first version of Visual Studio to support them was Microsoft Visual Studio 2005. So there goes that idea...</div><div><br /></div><div>Hmmm, what to do, what to do? Wouldn't it be nice if we could just tag a function as requiring entry/exit logging, and have our compiler toolchain to the work? Entry/exit logging is the sort of thing you want to be consistent, so it should suffice to define one set of rules that covers all functions. Let's take a little peek at what we could do with cmonster.<br /><br />First, we'll parse the source to get an AST. We'll locate all functions defined in the main file, and insert an "Entry" logging statement at the beginning of the body, and an "Exit" logging statement before each return statement in the body. At the end we dump the rewritten source to stdout, and we have a program, with logging, ready to be compiled.</div><div><br /></div><div><script src="https://gist.github.com/1269367.js?file=add_logging.py"></script></div><div><br /></div><div>Tada! Running this, we're given: <br /><br /><pre class="prettyprint lang-c">#include &lt;stdio.h&gt;<br />int main(int argc, const char *argv[])<br />{<br />    printf("Entering main at line 2\n");<br />    if (argc % 2 == 0)<br />    {<br />        printf("Returning from main at line 6\n");<br />        return 1;<br />    }<br />    else<br />    {<br />        printf("Returning from main at line 10\n");<br />        return 0;<br />    }<br />}</pre></div><div><br /></div><div><b><span class="Apple-style-span" style="font-size: large;">Future Work</span></b></div><div><br /></div><div>What we can't do yet is insert, replace, erase or modify declarations or statements directly in the AST, and have that reflected as a text insertion/replacement/erasure. For example, maybe I want to rename a function? Why can't I just go "function_declaration.name = 'new_name'". At the moment we'd need to replace the text identified by a source range... a bit clunky and manual. So&nbsp;I may add a more direct API in at a later stage. It should be doable, but may be a lot of work.</div><div><br />Also, the Visitor class defined in the above example could be called minimal at best. If there were any statements in the code that weren't handled by our visitor, the translation program would barf. I'll eventually build a complete Visitor class into cmonster to be reused. This should make writing translation tools a breeze; in our example, we would just override "visit_ReturnStatement" in the visitor.<br /><br />Now, I think it's about time I learnt <a href="http://golang.org/">Go</a>.</div>
