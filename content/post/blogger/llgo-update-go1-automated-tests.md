+++
title = "llgo update: Go1, automated tests"
date = 2012-04-08T21:44:00Z
updated = 2012-04-08T21:44:43Z
tags = ["go", "llgo", "gollvm", "llvm"]
blogimport = true 
aliases = [

  "/2012/04/llgo-update-go1-automated-tests.html",

]
[author]
	name = "Andrew Wilkins"
	uri = "https://plus.google.com/102738380796586573408"
+++

This week I finished up&nbsp;<a href="http://www.udacity.com/overview/Course/cs373">Udacity CS373: Programming a Robotic Car</a>, and also <i>finally </i>finished reading <a href="http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach">GEB</a>. So I'll hopefully be able to commit some more time to llgo again.<br /><div><br /></div><div>I moved on to Go's weekly builds a while back, and updated both llgo and gollvm to conform. I'm now on Go 1, as I hope most people are by now, and llgo is in good shape for Go 1 too. That's not to say that it compiles all of the Go 1 language, just that it runs in Go 1. Apart from that, I've just been working through some sample programs to increase the compiler's capability.</div><div><br /></div><div>One of the things that I've been a bit lazy about with llgo is automated testing, something I'm usually pretty keen on. I've grown anxious over regressions as time has gone on in the development, so I've spent a little bit of time this week putting together an automated test suite, which I <a href="https://groups.google.com/d/topic/golang-nuts/s_EehtIclUY/discussion">mentioned in golang-nuts</a> a few days ago. The test suite doesn't cover a great deal yet, but it has picked up a couple of bugs already.</div><div><br /></div><div>One of the numerous things I like about Go is its well integrated tooling. For testing, Go provides the <a href="http://golang.org/pkg/testing">testing</a>&nbsp;package, and <a href="http://golang.org/cmd/go/#Test_packages">go test</a>&nbsp;tool. So you write your unit tests according to the specifications in the "testing" package, run "go test", and your tests are all run. This is comparable to, say, Python, which has a similar "unittest" package. It is vastly more friendly than the various C++ unit test frameworks; that's in large part due to the way the Go language is designed, particularly with regard to how it fits into build systems and is parsed.</div><div><br /></div><div>In Go, everything you need to build a package is in the source (assuming you use the "go" command).</div><div><ul><li>The only external influences on the build process (environment variables GOOS, GOARCH, GOROOT, etc.) apply to the entire build procedure, not to single compilation units. Each variant will end up in a separate location when built: ${GOPATH}/pkg/${GOOS}_${GOARCH}/&lt;pkgname&gt;.</li><li>Platform-specific code is separated into multiple files (xxx_linux.go, xxx_windows.go, ...), and they're automatically matched with the OS/architecture by the "go" command.</li><li>Package dependencies are automatically and unambiguously resolved. Compare this with C/C++ headers, which might come from anywhere in the preprocessor's include path.</li></ul><div>So anyway, back to llgo's testing. It works just like this: I've created a separate program for each test case in the <span style="font-family: 'Courier New', Courier, monospace;">llgo/llgo/testdata</span>&nbsp;directory. Each of these programs corresponds to a test case written against the "testing" package, which does the following:</div></div><div><ol><li>Run the program using "go run", and store the output.</li><li>Redirect stdout to a pipe, and run a goroutine to capture the output to a string.</li><li>Compile the program using llgo's Compile API, and then interpret the resultant bitcode using gollvm's ExecutionEngine API.</li><li>Restore the original stdout, and compare the output with that of the original "go run".</li></ol><div>Pretty obvious I guess, but I was happy with how easy it was to do. Defer made the job of redirecting, restoring and closing file descriptors pain free; the go statement and channels made capturing and communicating the resulting data a cinch.</div></div><div><br /></div><div>This is getting a little ramble-ish, so I'll finish up. While testing, I discovered a problem with the way LLVM types are generated from <i>types.Type</i>'s, which basically means that they need to be cached and reused, rather that generated afresh each time. At the same time I intend to remove all references to LLVM from my clone of the "types" package, and offer my updates back to the Go team. It's not fully functional yet, but there's at least a few gaps that I've filled in.<br /><br />One last thing: LLVM 3.1 is due out May 14, so gollvm and llgo will no longer require LLVM from SVN. I really want to eliminate the dependency on llvm-config from the build of gollvm. I'm considering a dlopen/dlsym shim and removing the cgo dependency on LLVM. I'd be keen to hear some opinions, suggestions or alternatives.<br /><br />Until next time.</div>
