<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gollvm on awilkins.id.au</title>
    <link>https://awilkins.id.au/tags/gollvm/index.xml</link>
    <description>Recent content in Gollvm on awilkins.id.au</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://awilkins.id.au/tags/gollvm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>llgo update: Go1, automated tests</title>
      <link>https://awilkins.id.au/post/blogger/llgo-update-go1-automated-tests/</link>
      <pubDate>Sun, 08 Apr 2012 21:44:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/llgo-update-go1-automated-tests/</guid>
      <description>&lt;p&gt;This week I finished up&amp;nbsp;&lt;a href=&#34;http://www.udacity.com/overview/Course/cs373&#34;&gt;Udacity CS373: Programming a Robotic Car&lt;/a&gt;, and also &lt;i&gt;finally &lt;/i&gt;finished reading &lt;a href=&#34;http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach&#34;&gt;GEB&lt;/a&gt;. So I&amp;rsquo;ll hopefully be able to commit some more time to llgo again.&lt;br /&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;I moved on to Go&amp;rsquo;s weekly builds a while back, and updated both llgo and gollvm to conform. I&amp;rsquo;m now on Go 1, as I hope most people are by now, and llgo is in good shape for Go 1 too. That&amp;rsquo;s not to say that it compiles all of the Go 1 language, just that it runs in Go 1. Apart from that, I&amp;rsquo;ve just been working through some sample programs to increase the compiler&amp;rsquo;s capability.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;One of the things that I&amp;rsquo;ve been a bit lazy about with llgo is automated testing, something I&amp;rsquo;m usually pretty keen on. I&amp;rsquo;ve grown anxious over regressions as time has gone on in the development, so I&amp;rsquo;ve spent a little bit of time this week putting together an automated test suite, which I &lt;a href=&#34;https://groups.google.com/d/topic/golang-nuts/s_EehtIclUY/discussion&#34;&gt;mentioned in golang-nuts&lt;/a&gt; a few days ago. The test suite doesn&amp;rsquo;t cover a great deal yet, but it has picked up a couple of bugs already.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;One of the numerous things I like about Go is its well integrated tooling. For testing, Go provides the &lt;a href=&#34;http://golang.org/pkg/testing&#34;&gt;testing&lt;/a&gt;&amp;nbsp;package, and &lt;a href=&#34;http://golang.org/cmd/go/#Test_packages&#34;&gt;go test&lt;/a&gt;&amp;nbsp;tool. So you write your unit tests according to the specifications in the &amp;ldquo;testing&amp;rdquo; package, run &amp;ldquo;go test&amp;rdquo;, and your tests are all run. This is comparable to, say, Python, which has a similar &amp;ldquo;unittest&amp;rdquo; package. It is vastly more friendly than the various C++ unit test frameworks; that&amp;rsquo;s in large part due to the way the Go language is designed, particularly with regard to how it fits into build systems and is parsed.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;In Go, everything you need to build a package is in the source (assuming you use the &amp;ldquo;go&amp;rdquo; command).&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;The only external influences on the build process (environment variables GOOS, GOARCH, GOROOT, etc.) apply to the entire build procedure, not to single compilation units. Each variant will end up in a separate location when built: ${GOPATH}/pkg/${GOOS}_${GOARCH}/&amp;lt;pkgname&amp;gt;.&lt;/li&gt;&lt;li&gt;Platform-specific code is separated into multiple files (xxx_linux.go, xxx_windows.go, &amp;hellip;), and they&amp;rsquo;re automatically matched with the OS/architecture by the &amp;ldquo;go&amp;rdquo; command.&lt;/li&gt;&lt;li&gt;Package dependencies are automatically and unambiguously resolved. Compare this with C/C++ headers, which might come from anywhere in the preprocessor&amp;rsquo;s include path.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;So anyway, back to llgo&amp;rsquo;s testing. It works just like this: I&amp;rsquo;ve created a separate program for each test case in the &lt;span style=&#34;font-family: &#39;Courier New&#39;, Courier, monospace;&#34;&gt;llgo/llgo/testdata&lt;/span&gt;&amp;nbsp;directory. Each of these programs corresponds to a test case written against the &amp;ldquo;testing&amp;rdquo; package, which does the following:&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;ol&gt;&lt;li&gt;Run the program using &amp;ldquo;go run&amp;rdquo;, and store the output.&lt;/li&gt;&lt;li&gt;Redirect stdout to a pipe, and run a goroutine to capture the output to a string.&lt;/li&gt;&lt;li&gt;Compile the program using llgo&amp;rsquo;s Compile API, and then interpret the resultant bitcode using gollvm&amp;rsquo;s ExecutionEngine API.&lt;/li&gt;&lt;li&gt;Restore the original stdout, and compare the output with that of the original &amp;ldquo;go run&amp;rdquo;.&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;Pretty obvious I guess, but I was happy with how easy it was to do. Defer made the job of redirecting, restoring and closing file descriptors pain free; the go statement and channels made capturing and communicating the resulting data a cinch.&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;This is getting a little ramble-ish, so I&amp;rsquo;ll finish up. While testing, I discovered a problem with the way LLVM types are generated from &lt;i&gt;types.Type&lt;/i&gt;&amp;rsquo;s, which basically means that they need to be cached and reused, rather that generated afresh each time. At the same time I intend to remove all references to LLVM from my clone of the &amp;ldquo;types&amp;rdquo; package, and offer my updates back to the Go team. It&amp;rsquo;s not fully functional yet, but there&amp;rsquo;s at least a few gaps that I&amp;rsquo;ve filled in.&lt;br /&gt;&lt;br /&gt;One last thing: LLVM 3.1 is due out May 14, so gollvm and llgo will no longer require LLVM from SVN. I really want to eliminate the dependency on llvm-config from the build of gollvm. I&amp;rsquo;m considering a dlopen/dlsym shim and removing the cgo dependency on LLVM. I&amp;rsquo;d be keen to hear some opinions, suggestions or alternatives.&lt;br /&gt;&lt;br /&gt;Until next time.&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Imports in llgo, jr.</title>
      <link>https://awilkins.id.au/post/blogger/imports-in-llgo-jr./</link>
      <pubDate>Sun, 19 Feb 2012 13:50:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/imports-in-llgo-jr./</guid>
      <description>&lt;p&gt;So I realised I&amp;rsquo;m a doofus the other day, when I started getting closer to completion on producing export metadata in llgo. Rolling my own import mechanism is unnecessary for now. Instead, I can just lean on the import mechanism that exists in the standard library (well, &lt;a href=&#34;http://weekly.golang.org/doc/go1.html#exp&#34;&gt;until Go 1&lt;/a&gt; at least): go/types/GcImporter.&lt;br /&gt;&lt;br /&gt;I&amp;rsquo;ve modified llgo to use go/ast/NewPackage, rather than the old code I had that was using go/parser/ParseFiles. The NewPackage function takes an optional &amp;ldquo;importer&amp;rdquo; object which will be used for inter-package dependency resolution, whereas ParseFiles does no resolution. The standard GcImporter type may be used to identify exports by interrogating the object and archive files in $GOROOT. The AST that&amp;rsquo;s generated is filled in with external declarations, so it&amp;rsquo;s then up to llgo to convert those into LLVM external declarations. Easy peasy.&lt;br /&gt;&lt;br /&gt;Now it&amp;rsquo;s time to come up with a symbol naming scheme. Without having thought about it too hard, I&amp;rsquo;m going to start off with the assumption that the absolute name of the symbol (package+name), with slashes converted to dots, will do the trick. Once I&amp;rsquo;ve implemented that, I&amp;rsquo;ll need to start work on the runtime in earnest. It&amp;rsquo;s also high time I put some automated tests in place, since things are starting to get a little stabler.&lt;br /&gt;&lt;br /&gt;In the long term I&amp;rsquo;ll probably want to continue on with my original plan, which is to generate module-level metadata in the LLVM bitcode, and then extract this in a custom importer. It should be quite straightforward.&amp;nbsp;Earlier this week I wrapped up some updates to gollvm to add an API to make generating &lt;a href=&#34;http://llvm.org/docs/SourceLevelDebugging.html&#34;&gt;source-level debugging metadata&lt;/a&gt; simpler. This will be useful not only for describing exports, but also for what it&amp;rsquo;s intended: generating &lt;a href=&#34;http://dwarfstd.org/&#34;&gt;DWARF&lt;/a&gt;&amp;nbsp;debug information.&lt;br /&gt;&lt;br /&gt;In other news: my wife just ordered the 1-4a box set of&amp;nbsp;&lt;a href=&#34;http://www-cs-staff.stanford.edu/~uno/taocp.html&#34;&gt;The Art of Computer Programming&lt;/a&gt;&amp;nbsp;for me. At the moment I am slowly making way through&amp;nbsp;&lt;a href=&#34;http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach&#34;&gt;GÃ¶del, Escher, Bach: an Eternal Golden Braid&lt;/a&gt;, and so far, so good. Looking forward to more light reading for the bus/train!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>