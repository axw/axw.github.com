<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on awilkins.id.au</title>
    <link>https://awilkins.id.au/post/index.xml</link>
    <description>Recent content in Posts on awilkins.id.au</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 06 Feb 2017 17:52:06 +0800</lastBuildDate>
    <atom:link href="https://awilkins.id.au/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>New in Juju 2.1: Prometheus Metrics</title>
      <link>https://awilkins.id.au/post/juju-2.1-prometheus/</link>
      <pubDate>Mon, 06 Feb 2017 17:52:06 +0800</pubDate>
      
      <guid>https://awilkins.id.au/post/juju-2.1-prometheus/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://jujucharms.com/&#34;&gt;Juju&lt;/a&gt; is an application modelling tool,
enabling &amp;ldquo;model-driven operations&amp;rdquo;. I won&amp;rsquo;t go into detail about
what Juju is in this blog post, so if you&amp;rsquo;re new to Juju I suggest
clicking on the link and reading a bit more.&lt;/p&gt;

&lt;p&gt;Juju is a distributed application, with a &amp;ldquo;controller&amp;rdquo; cluster that
manages cloud resources (machines, networks, volumes, etc.), and
applications that use those resources. The controller cluster is
currently based on top of MongoDB, utilising replica sets for data
replication and leadership election.&lt;/p&gt;

&lt;p&gt;As well as the controller cluster, Juju agents run on every virtual
machine that the controller manages. The controllers, and those agents,
each run many fine-grained, but dedicated &amp;ldquo;workers&amp;rdquo;. For example,
each agent runs a worker to detect block devices and publish that
information to the controller cluster; each controller runs a worker
to maintain the replica sets in MongoDB.&lt;/p&gt;

&lt;p&gt;Many things can go wrong in a distributed system. Network partitions
can cause system-wide failures. Bad actors (badly written; less often,
malicious) may starve others of resources. Failure to release memory
or file handles leads to exhaustion, causing a DoS. Juju has seen its
fair share of each of these problems.&lt;/p&gt;

&lt;p&gt;To combat such issues, we have recently added Prometheus monitoring to
Juju. As of Juju 2.1, Juju controllers and agents will export Prometheus
metrics. There are two ways to get at them:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(on controllers) an HTTPS endpoint, https://&amp;hellip;:17070/introspection/metrics.&lt;/li&gt;
&lt;li&gt;(on Linux agents) an abstract domain socket, @jujud-machine-&amp;lt;machine-ID&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://awilkins.id.au/images/prometheus-juju-metrics.png&#34; alt=&#34;Juju metrics available from Prometheus&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;configuring-prometheus-to-scrape-juju-controllers&#34;&gt;Configuring Prometheus to scrape Juju controllers&lt;/h2&gt;

&lt;p&gt;To configure Prometheus to scrape metrics from Juju controllers, you will
need to add a new scrape target to Prometheus. The metrics endpoint requires
authorisation, so you will need to configure a user and password for
Prometheus to use:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;$ juju add-user prometheus
$ juju change-user-password prometheus
new password: &amp;lt;password&amp;gt;
type new password again: &amp;lt;password&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For this new &amp;ldquo;prometheus&amp;rdquo; user to be able to access the metrics endpoint,
you must grant the user read access to the controller model:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;$ juju grant prometheus read controller
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This gives the prometheus user just enough permission to read information
on the controller, without allowing it to make changes, which would not
be ideal for a monitoring application.&lt;/p&gt;

&lt;p&gt;Juju serves the metrics over HTTPS, currently with no option of degrading
to HTTP. You can configure your Prometheus to skip validation, or you can
store the controller’s CA certificate in a file for Prometheus to verify
the server’s certificate against:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;$ juju controller-config ca-cert &amp;gt; /path/to/juju-ca.crt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can now add a scrape target to Prometheus. Modify prometheus.yml, adding
the following scrape target:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;scrape_configs:
  job_name: juju
    metrics_path: /introspection/metrics
    scheme: https
    static_configs:
      targets: [&#39;&amp;lt;controller-address&amp;gt;:17070&#39;]
    basic_auth:
      username: user-prometheus
      password: &amp;lt;password&amp;gt;
    tls_config:
      ca_file: /path/to/juju-ca.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://awilkins.id.au/images/prometheus-juju-api-requests-total.png&#34; alt=&#34;Juju API requests total metric&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;configuring-prometheus-to-scrape-juju-agents&#34;&gt;Configuring Prometheus to scrape Juju agents&lt;/h2&gt;

&lt;p&gt;To expose the metrics of agents, you can deploy the &lt;a href=&#34;https://jujucharms.com/u/axwalk/juju-introspection&#34;&gt;juju-introspection&lt;/a&gt;
charm onto that agent&amp;rsquo;s machine. For example, on machine 1, you would
run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;juju deploy ~axwalk/juju-introspection --to 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The metrics of that agent can then be obtained via:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://&amp;lt;machine-1-address&amp;gt;:19090/agents/machine-1/metrics
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this is not an officially supported charm. The code for it is available at:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/axw/juju-introspection-charm&#34;&gt;https://github.com/axw/juju-introspection-charm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/axw/juju-introspection-proxy&#34;&gt;https://github.com/axw/juju-introspection-proxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Old blog posts</title>
      <link>https://awilkins.id.au/post/old-posts/</link>
      <pubDate>Sat, 31 Dec 2016 15:30:35 +0800</pubDate>
      
      <guid>https://awilkins.id.au/post/old-posts/</guid>
      <description>&lt;p&gt;I have finally gotten around to moving off Blogger,
and over to using &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt;. The old
blog posts have been imported, and are also accessible
at &lt;a href=&#34;https://axwalk.blogspot.com&#34;&gt;my old Blogger site&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Availability Zones in Juju</title>
      <link>https://awilkins.id.au/post/blogger/availability-zones-in-juju/</link>
      <pubDate>Tue, 19 Aug 2014 10:49:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/availability-zones-in-juju/</guid>
      <description>&lt;p&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;/div&gt;&lt;div style=&#34;text-align: left;&#34;&gt;You would be forgiven for thinking that I&amp;rsquo;d fallen off the face of the earth, considering how long it has been since I last wrote. I&amp;rsquo;ve been busy with my day job, moving into a new house; life in general. Work on &lt;a href=&#34;https://github.com/go-llvm/llgo&#34;&gt;llgo&lt;/a&gt;&amp;nbsp;has been progressing, mostly due to Peter Collingbourne. I&amp;rsquo;ll have more to say about llgo&amp;rsquo;s progress in future posts.&lt;/div&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;text-align: left;&#34;&gt;This post is about some of the work I&amp;rsquo;ve done on&amp;nbsp;&lt;a href=&#34;http://juju.ubuntu.com/&#34;&gt;Juju&lt;/a&gt;&amp;nbsp;recently. Well, semi-recently; this post has been sitting in my drafts for a little while, waiting for the new 1.20.5 release to be announced.&lt;/div&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://3.bp.blogspot.com/-Pw7IeMRzbtM/U_K3cyQ5SRI/AAAAAAAAhIY/-Pl2Dh3TgGI/s1600/andnowforsomethingcompletelydifferent.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://3.bp.blogspot.com/-Pw7IeMRzbtM/U_K3cyQ5SRI/AAAAAAAAhIY/-Pl2Dh3TgGI/s1600/andnowforsomethingcompletelydifferent.png&#34; height=&#34;320&#34; width=&#34;225&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;h2&gt;Availability Zones in Juju&lt;/h2&gt;One of the major focuses of the &lt;a href=&#34;https://juju.ubuntu.com/docs/reference-release-notes.html&#34;&gt;Juju 1.20 release&lt;/a&gt; has been around high availability (HA). There are two sides to this: high availability of Juju itself, and high availability of your deployed services. We’ll leave the “Juju itself” side for another day, and talk about HA charms/services.&lt;br /&gt;&lt;br /&gt;Until now, if you deployed a service via a charm with Juju, your cloud instance containing the service unit would be allocated wherever the cloud provider decided best. Most cloud providers split their compute services up into geographic regions (“us-east-1” in Amazon EC2, “US West” in Microsoft Azure, etc.). Some providers also break those regions down into “availability zones” (though the actual term may vary between providers, we use the term availability zone to describe the concept). An availability zone is essentially an isolated subset of a region.&lt;br /&gt;&lt;br /&gt;If you’re developing an application that demands high availability, then you probably want to make sure your application is spread across availability zones. Some providers will guarantee a service level agreement (SLA) if you do this, such as on Microsoft Azure. Provided that you allocate at least two VMs to a “Cloud Service” on Azure, then you’re guaranteed a 99.95% uptime under the SLA and you get reimbursed if the guarantee isn’t met.&lt;br /&gt;&lt;br /&gt;In Juju 1.20, there are two options for distributing your service units across availability zones: explicit (akin to machine placement) and automatic. So far we have enabled explicit availability zone placement in the Amazon EC2 and OpenStack (Havana onwards) providers, with support for the &lt;a href=&#34;https://maas.ubuntu.com/&#34;&gt;MAAS&lt;/a&gt; provider on the horizon. To add a new machine to a specific availability zone, use the “zone=” placement directive as below:&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;juju add-machine zone=us-east-1b&lt;/blockquote&gt;&lt;br /&gt;As well as support for explicit zone placement, we’ve implemented automatic spreading of services units across availability zones for Amazon EC2, OpenStack and Microsoft Azure. When cloud instances are provisioned, they will be allocated to an availability zone according to the density of the availability zone population for related instances. Two cloud instances are considered related if they both contain units of a common service, or if they are both Juju state servers.&lt;br /&gt;&lt;br /&gt;To illustrate automatic spread, consider the mongodb charm. You’re going to use MongoDB as the datastore for your application, and you want to make sure the datastore is highly available; to do that, you’ll want to create a &lt;a href=&#34;http://docs.mongodb.org/manual/replication/&#34;&gt;MongoDB replica set&lt;/a&gt;. It’s trivial to do this with the mongodb Juju charm:&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;juju deploy -n 3 mongodb&lt;/blockquote&gt;&lt;br /&gt;Wait a little while and you’ll have a 3-node MongoDB replica set. If a node happens to disappear, then the replica set will rejig itself so that there is a master (if the master was in fact lost) and everything should continue to work. If all the nodes go away, then you’re in trouble. This is where you want to go a step further and ensure your nodes are distributed across availability zones for greater resilience to failure. As of Juju 1.20, that “juju deploy” you just did handles that all for you: your 3 nodes will be uniformly spread across availability zones in the environment. If you add units to the service, they will also be spread across the zones according to how many other units of the service are in the zones. Let’s see what Juju did…&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;$ juju status mongodb | grep instance-id&lt;br /&gt;instance-id: i-7a6d2b50&lt;br /&gt;instance-id: i-ff1562d4&lt;br /&gt;instance-id: i-627f0a30&lt;/blockquote&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;$ ec2-describe-availability-zones&lt;br /&gt;AVAILABILITYZONE us-east-1a available us-east-1&lt;br /&gt;AVAILABILITYZONE us-east-1b available us-east-1&lt;br /&gt;AVAILABILITYZONE us-east-1d available us-east-1&lt;/blockquote&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;$ ec2-describe-instance-status i-7a6d2b50 i-ff1562d4 i-627f0a30 | grep i-&lt;br /&gt;INSTANCE i-627f0a30 us-east-1d running 16 ok ok active&lt;br /&gt;INSTANCE i-ff1562d4 us-east-1a running 16 ok ok active&lt;br /&gt;INSTANCE i-7a6d2b50 us-east-1b running 16 ok ok active&lt;/blockquote&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;(Note: the ec2-* commands are available in the ec2-api-tools package.)&lt;/blockquote&gt;&lt;br /&gt;Juju has distributed the mongodb units so that there is one in each zone, so if one zone is impaired the others will be unaffected. If we add a unit, it will go into one of the zones with the fewest mongodb units.&lt;br /&gt;&lt;br /&gt;Explicit placement is currently only supported by Juju’s Amazon EC2 and OpenStack providers, but automatic spread is also supported by the Microsoft Azure provider. Due to the way that Microsoft Azure ties together availability zones and load balancing, it is currently necessary to forego “density” (i.e. explicit machine placement) in order to support automatic spread. If you are upgrading an existing environment to 1.20, then automatic spread will not be enabled. Newly created environments enable spread (and disable placement) by default, with an option to disable (availability-sets-enabled=false in environments.yaml).&lt;br /&gt;&lt;br /&gt;Enjoy.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>llgo on ssa</title>
      <link>https://awilkins.id.au/post/blogger/llgo-on-ssa/</link>
      <pubDate>Mon, 06 Jan 2014 22:02:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/llgo-on-ssa/</guid>
      <description>&lt;p&gt;Hello there!&lt;br /&gt;&lt;br /&gt;I&amp;rsquo;ve been busy hacking on &lt;a href=&#34;http://github.com/axw/llgo&#34; target=&#34;_blank&#34;&gt;llgo&lt;/a&gt; again. In case you&amp;rsquo;re new here: llgo is a &lt;a href=&#34;http://golang.org/&#34; target=&#34;_blank&#34;&gt;Go&lt;/a&gt; frontend for &lt;a href=&#34;http://llvm.org/&#34; target=&#34;_blank&#34;&gt;LLVM&lt;/a&gt; that I&amp;rsquo;ve been working on for the past ~2 years on and off. It&amp;rsquo;s been quite a while since I last wrote; there has been a bunch of new work since, so I have some things to talk about at last.&lt;br /&gt;&lt;br /&gt;A few months ago, I started working on rewriting swathes of llgo&amp;rsquo;s internals to base it on &lt;a href=&#34;http://godoc.org/code.google.com/p/go.tools/ssa&#34;&gt;go.tools/ssa&lt;/a&gt;. LLVM uses an &lt;a href=&#34;http://en.wikipedia.org/wiki/Static_single_assignment_form&#34;&gt;SSA&lt;/a&gt; representation, which made the process fairly straightforward. Basing llgo on go.tools/ssa gives me much higher confidence in the quality of the output; it also presented a good opportunity to clean up llgo&amp;rsquo;s source itself, which I have begun, but certainly not finished. llgo is now able to compile all packages in the standard library, except those that require cgo (net, os/user, runtime/cgo).&lt;br /&gt;&lt;br /&gt;llgo now works something like this:&lt;br /&gt;&lt;ol&gt;&lt;li&gt;Go source is scanned and parsed by go/ast and go/parser, producing an AST;&lt;/li&gt;&lt;li&gt;The AST is fed into go/types, type-checking;&lt;/li&gt;&lt;li&gt;The output of go/types is passed onto go.tools/ssa, which generates the SSA form;&lt;/li&gt;&lt;li&gt;llgo translates the go.tools/ssa SSA form into an LLVM module,&lt;/li&gt;&lt;li&gt;llgo-build links the LLVM modules for a program together and translates to an executable.&lt;/li&gt;&lt;/ol&gt;&lt;br /&gt;go.tools/ssa supports translating a whole program to SSA form, but llgo works in the traditional way: packages are translated one at a time. Whole program optimisation is enabled by linking the LLVM modules together, prior to any translation to machine code.&lt;br /&gt;&lt;br /&gt;There were a few bits that I stumbled on, when rewriting. Alan Donovan, the author of go.tools/ssa, was kind enough to give me some assistance along the way. Anyway, the main issues I had were:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Translating Phi nodes requires a bit of finessing, to ensure processing of the Phi or the edges is not order-sensitive. This was dealt with by generating placeholder values for instructions that haven&amp;rsquo;t yet been visited, and then replacing them later.&lt;/li&gt;&lt;li&gt;ssa.Index is emitted for indexing into arrays. If an array is in a register, then indexing it means extracting a value; in LLVM, an array element extraction requires a constant index. This is currently kludged by storing to a temporary alloca, and using the getelementptr LLVM instruction. Hopefully I&amp;rsquo;m missing something and this is easily fixed.&lt;/li&gt;&lt;li&gt;The Recover block is not dominated by the entry block, so it may not be valid for it to refer to the Alloc instructions for parameters and results. To deal with this, I generate a prologue block that contains the param/result Allocs; the prologue block conditionally jumps to either the recover or entry block, depending on panic/recover control flow. Alan has agreed to do something along these lines in go.tools/ssa.&lt;/li&gt;&lt;li&gt;The ssa.Next instruction required some assumptions to be made about block ordering and instruction placement, in order to be able to translate string-range using Phi nodes. Recent changes to go.tools/ssa exposed&amp;nbsp;the dominator tree, making it possible to do away with the assumption now.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;Various significant changes have been made during the course of the migration to go.tools/ssa:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Interfaces are now represented like in gc: empty interfaces with the runtime type &amp;amp; data, non-empty interfaces with an &amp;ldquo;itab&amp;rdquo; and data. Russ Cox wrote &lt;a href=&#34;http://research.swtch.com/interfaces&#34;&gt;an article about the interface representation&lt;/a&gt; back in 2009.&lt;/li&gt;&lt;li&gt;Panic/recover (and defer, by consequence) are now using setjmp/longjmp. I had been using exceptions, but it was rightly pointed out to me that this wouldn&amp;rsquo;t work unless there were a way of doing non-call exceptions in LLVM (which has not been implemented). The setjmp/longjmp approach incurs a cost for every function that may defer or recover, but it works without modifications to LLVM. Perhaps this will be revisited in the future.&lt;/li&gt;&lt;li&gt;go/types/typemap is now used for mapping types.Types to runtime type descriptors and LLVM types. Runtime type descriptors are now generated more completely, and more correctly. Identical type descriptors will now be merged at link-time.&lt;/li&gt;&lt;li&gt;llgo no longer generates conditional branching for calls to non-global functions, when comparing structs, or in map iteration. Apart from producing better code, this makes it much simpler to work with go.tools/ssa, which has its own idea about how the SSA basic blocks relate to one another.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;There have also been miscellaneous bug fixes, and improvements, not directly related to the move to go.tools/ssa. Some highlights:&lt;/div&gt;&lt;ul&gt;&lt;li&gt;A custom importer/exporter, thanks to &lt;a href=&#34;https://github.com/quarnster&#34;&gt;Fredrik Ehnbom&lt;/a&gt;. The importer side is disabled at the moment, due to an apparent &lt;a href=&#34;https://code.google.com/p/go/issues/detail?id=7028&#34;&gt;bug in go.tools/ssa&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;Debugger support, thanks again to Fredrik Ehnbom. I haven&amp;rsquo;t reenabled it since the move to go.tools/ssa. I&amp;rsquo;ll get onto that real soon now, because debugging without it can be tiresome.&lt;/li&gt;&lt;li&gt;llgo-build can now take a &amp;ldquo;-test&amp;rdquo; flag that causes llgo-build to compile the test Go files, yet again thanks to Fredrik Ehnbom. This is currently reliant on the binary importer being enabled, so it won&amp;rsquo;t work out of the box until that bug is fixed.&lt;/li&gt;&lt;li&gt;Shifts now generate correct values for shifts greater than the width of the lhs operand.&lt;/li&gt;&lt;li&gt;Signed integer conversions now sign-extend correctly.&lt;/li&gt;&lt;li&gt;bytes.Compare now works as it should (-1, 0, 1, not &amp;lt;0, 0, &amp;gt;0). &amp;ldquo;llgo-build -test bytes&amp;rdquo;: PASS&lt;/li&gt;&lt;li&gt;llgo-build can now take a &amp;ldquo;-run&amp;rdquo; flag that causes llgo-build to execute and then dispose of the resulting binary.&lt;/li&gt;&lt;li&gt;Type strings are propagated to LLVM types, making the IR more legible, thanks to &lt;a href=&#34;https://github.com/tmc&#34;&gt;Travis Cline&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;I &lt;i&gt;think&lt;/i&gt; that&amp;rsquo;s everything. I have various things I&amp;rsquo;d like to tackle now, but not enough time to do it all at once. If you&amp;rsquo;re interested in helping out then there&amp;rsquo;s plenty to do, including:&lt;/div&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Move to using libgo. Ideally the gc runtime would be rewritten in Go already, but that&amp;rsquo;s not going to happen just yet. The compiler and linker are due to be rewritten in Go soon, which is a lot of work as it is.&lt;/li&gt;&lt;li&gt;Finish off runtime type descriptor generation (notably, type algorithms).&lt;/li&gt;&lt;li&gt;Get PNaCl support working again. This should be pretty close, but requires the binary importer to be enabled.&lt;/li&gt;&lt;li&gt;Implement cgo support.&lt;/li&gt;&lt;li&gt;Implement bounds checking, nil pointer checks, etc.&lt;/li&gt;&lt;li&gt;Get garbage collection working. There&amp;rsquo;s &lt;a href=&#34;https://github.com/axw/llgo/pull/108&#34;&gt;Pull Request #108&lt;/a&gt;, but this is perpetuating the problem that is llgo&amp;rsquo;s custom runtime. Since GC is fairly invasive, I don&amp;rsquo;t want to go tying llgo to that runtime any more than it is currently. I expect this will have to wait until libgo is integrated.&lt;/li&gt;&lt;li&gt;Escape analysis. This is a must-have, but not immediately&amp;nbsp;necessarily. The implementation should be based&amp;nbsp;on go.tools/ssa, interfacing with the exporter/importer to record/consume information about external functions.&lt;/li&gt;&lt;li&gt;Make use of go.tools/ssa/ssautil/Switches. This is an optimisation, so again, not immediately necessary.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;If you want to have a play around, then grab LLVM and Go, and then:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;go get github.com/axw/llgo/cmd/llgo-dist &amp;amp;&amp;amp; llgo-dist&lt;/li&gt;&lt;li&gt;llgo-build &amp;lt;some/package&amp;gt; &lt;i&gt;or&lt;/i&gt; llgo-build file1.go, file2.go, &amp;hellip;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;Let me know how you get on with that.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Here&amp;rsquo;s hoping 2014 can be a productive year for llgo. Happy new year.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;Cheers,&lt;br /&gt;Andrew&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>llgo update #14</title>
      <link>https://awilkins.id.au/post/blogger/llgo-update-14/</link>
      <pubDate>Fri, 16 Aug 2013 22:55:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/llgo-update-14/</guid>
      <description>&lt;p&gt;Ahoy there, mateys!&lt;br /&gt;&lt;br /&gt;It&amp;rsquo;s been three months since our last correspondence. Apologies for the negligence. I&amp;rsquo;ve been busy, as usual, but it&amp;rsquo;s more self-inflicted than usual. I&amp;rsquo;ve taken up a new role at Canonical, working on &lt;a href=&#34;http://juju.ubuntu.com/&#34;&gt;Juju&lt;/a&gt;.&amp;nbsp;I&amp;rsquo;m really excited about Juju (both the concept and realisation), and the fact that it&amp;rsquo;s written in Go is icing on the cake. Working remotely is taking some getting used to, but so far it&amp;rsquo;s been pretty swell. Anyway, you didn&amp;rsquo;t come here to read about that, did you?&lt;br /&gt;&lt;br /&gt;I&amp;rsquo;m still working on &lt;a href=&#34;http://github.com/axw/llgo&#34;&gt;llgo&lt;/a&gt; in the background, quietly prodding it along towards the &lt;a href=&#34;https://github.com/axw/llgo/issues?milestone=1&amp;amp;state=open&#34;&gt;0.1 milestone&lt;/a&gt;. There&amp;rsquo;s just one big ticket item left, and that&amp;rsquo;s partially done now: channels. I&amp;rsquo;ve just finished porting the basics of channels from gc&amp;rsquo;s standard library to llgo&amp;rsquo;s runtime. That doesn&amp;rsquo;t include select, which is entirely missing. When that&amp;rsquo;s done, I&amp;rsquo;ll be content to release 0.1.&lt;br /&gt;&lt;br /&gt;So what&amp;rsquo;s new since last time?&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;There&amp;rsquo;s a new llgo-build tool, which takes the pain out of building packages and programs with llgo and the LLVM toolchain. Just run &amp;ldquo;llgo-build &amp;lt;package&amp;gt;&amp;rdquo;, and you&amp;rsquo;ll either build and install a package, or build a program in the working directory. There&amp;rsquo;s no freshness checking, so you&amp;rsquo;re currently required to manually build all dependencies before building a program.&lt;/li&gt;&lt;li&gt;Simplified building against PNaCl: llgo-dist now accepts a &amp;ldquo;-pepper&amp;rdquo; option, which points to a NaCl SDK.&lt;/li&gt;&lt;li&gt;Implemented support for map literals.&lt;/li&gt;&lt;li&gt;Implemented complex number arithmetic.&lt;/li&gt;&lt;li&gt;Implemented channels (apart from anything select-related)&lt;/li&gt;&lt;li&gt;Numerous bug fixes.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;In my previous post I talked about having implemented panic/recover, and having implemented them in terms of DWARF exception handling. Well, it looks like PNaCl isn&amp;rsquo;t going to support that, at least initially, so a setjmp/longjmp version is likely inevitable now.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;I also said I would be working on a temporary for of cmd/go. I gave up on that, after hitting a few stumbling blocks. I figured it was more important to actually get the compiler and runtime working than get bogged down in the tooling, hence the simpler llgo-build tool.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;That&amp;rsquo;s about it! &amp;ldquo;Feature complete&amp;rdquo; is getting closer, though lots of things still don&amp;rsquo;t work very nicely. Still no garbage collection, no proper escape analysis, etc. Those will come in time.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;For now, though&amp;hellip; I think I might go catch up on some sleep.&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>llgo on Go 1.1</title>
      <link>https://awilkins.id.au/post/blogger/llgo-on-go-1.1/</link>
      <pubDate>Sat, 18 May 2013 21:28:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/llgo-on-go-1.1/</guid>
      <description>&lt;p&gt;Hi folks,&lt;br /&gt;&lt;br /&gt;(For those of you coming from HN/Twitter/elsewhere, this is a post about &lt;a href=&#34;https://github.com/axw/llgo&#34;&gt;llgo&lt;/a&gt;. llgo is an LLVM frontend for the Go programming language).&lt;br /&gt;&lt;br /&gt;In my &lt;a href=&#34;http://blog.awilkins.id.au/2013/03/llgo-update-12.html&#34;&gt;last post&lt;/a&gt; I mentioned that work had began on moving to Go 1.1 compatibility; this has been my primary focus since then. Since Go 1.1 is now released (woohoo!), I&amp;rsquo;ve gone ahead and pulled all the changes back into the master branch on GitHub. If you want to play around, you can do the following:&lt;br /&gt;&lt;br /&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&#34;http://golang.org/doc/install&#34;&gt;Get Go 1.1&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;http://llvm.org/releases/&#34;&gt;Get Clang and LLVM&lt;/a&gt; (I&amp;rsquo;ve tested with 3.2, Ubuntu x86-64). Make sure llvm-config is in your $PATH.&lt;/li&gt;&lt;li&gt;Run &amp;ldquo;go get github.com/axw/llgo/cmd/llgo-dist&amp;rdquo;&lt;/li&gt;&lt;li&gt;Run &amp;ldquo;llgo-dist&amp;rdquo;. This will install llgo into $GOBIN, and build the runtime.&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;The biggest new feature would have to be: defer, panic and recover (I&amp;rsquo;m lumping them together as they&amp;rsquo;re closely related). I&amp;rsquo;ve implemented them on top of &lt;a href=&#34;http://llvm.org/docs/ExceptionHandling.html&#34;&gt;LLVM&amp;rsquo;s exception handling support&lt;/a&gt;. The panic and recover functions are currently tied to DWARF exception handling, though it&amp;rsquo;s simple enough that it should be feasible to use setjmp/longjmp on platforms where DWARF exception handling isn&amp;rsquo;t viable.&lt;br /&gt;&lt;br /&gt;Aside from that, there&amp;rsquo;s some new bits and bobs:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Method sets are handled properly now (or at least not completely wrong like before). This means you can use a embedded types&amp;rsquo; methods to satisfy an interface.&lt;/li&gt;&lt;li&gt;&amp;ldquo;return&amp;rdquo; requirements are now checked by go/types&lt;/li&gt;&lt;li&gt;cap() is now implemented for slices.&lt;/li&gt;&lt;li&gt;llgo-dist now builds against the LLVM static libraries (if available) by default now, with an option for building against the shared libraries.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;I&amp;rsquo;ll be working on a temporary fork of cmd/go to build programs with llgo, while a long-term solution is figured out. I&amp;rsquo;d also like to get PNaCl integration working again, given that its release is nigh.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;That&amp;rsquo;s all for now.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>llgo update #12</title>
      <link>https://awilkins.id.au/post/blogger/llgo-update-12/</link>
      <pubDate>Fri, 01 Mar 2013 21:50:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/llgo-update-12/</guid>
      <description>&lt;p&gt;Oh my, it&amp;rsquo;s been a while.&lt;br /&gt;&lt;br /&gt;In my &lt;a href=&#34;http://blog.awilkins.id.au/2012/12/go-in-browser-llgo-does-pnacl.html&#34;&gt;previous post&lt;/a&gt;&amp;nbsp;I wrote about llgo and PNaCl. I haven&amp;rsquo;t had much time to play with PNaCl recently, but I have been prodding llgo along. In February, my wife gave birth to our son, Jeremy, so naturally I&amp;rsquo;ve been busy. But anyway, let&amp;rsquo;s talk about what has been happening in llgo. Quick, while he&amp;rsquo;s sleeping!&lt;br /&gt;&lt;br /&gt;Feature-wise, there&amp;rsquo;s nothing terribly exciting going on. Without getting too boring, what&amp;rsquo;s new is:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;A new &amp;ldquo;go1.1&amp;rdquo; branch in the Git repository. The go1.1 branch aims to make llgo compatible with the Go tip, and will replace the master branch when Go 1.1 is released.&lt;/li&gt;&lt;li&gt;Removed llgo/types (a fork of the old exp/types package), and moved to go/types.&lt;/li&gt;&lt;li&gt;Updated runtime type representations to match those from gc&amp;rsquo;s tip (thanks to minux for initiating this effort).&lt;/li&gt;&lt;li&gt;Updated to use architecture-specific size for &amp;ldquo;int&amp;rdquo; (same as uintptr).&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/axw/llgo/commit/e26ff1f4a7ea661ff77b12a4cb7273f770d5a928&#34;&gt;Changed function representation to be a pair of pointers&lt;/a&gt;, to avoid trampolines/runtime code generation for closures. The rationale is the same as for rsc&amp;rsquo;s proposal for Go 1.1; using runtime code generation limits the environments that Go can run in (e.g. PNaCl).&lt;/li&gt;&lt;li&gt;A slew of bug fixes and minor enhancements.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;The go/types change in particular was not a small one, but llgo came out much better at the end. As of the most recent go/types commits, llgo now passes all of its tests in the go1.1 branch. Now I can get back to implementing features again.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;That&amp;rsquo;s about all there is to report. It has been &lt;a href=&#34;https://github.com/axw/llgo/issues/26#issuecomment-13347764&#34;&gt;suggested&lt;/a&gt;&amp;nbsp;that I set up some milestones in the GitHub project; I will spend a bit of time coming up with what I think are the bare essentials for a 0.1 release, and what would constitute future releases and so on.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;One last thing: there&amp;rsquo;s a new(ish) &lt;a href=&#34;https://groups.google.com/forum/?fromgroups#!forum/llgo-dev&#34;&gt;llgo-dev&lt;/a&gt; mailing list. If you want to get involved, or just lurk, come and join the party.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Until next time.&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go in the Browser: llgo does PNaCl</title>
      <link>https://awilkins.id.au/post/blogger/go-in-the-browser-llgo-does-pnacl/</link>
      <pubDate>Sun, 09 Dec 2012 12:45:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/go-in-the-browser-llgo-does-pnacl/</guid>
      <description>&lt;p&gt;&lt;br /&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Last week I briefly &lt;a href=&#34;https://plus.google.com/102738380796586573408/posts/HdvvfFqMvig&#34;&gt;reported on Google+&lt;/a&gt; that I had written a Go-based &lt;a href=&#34;https://developers.google.com/native-client/&#34;&gt;Native Client module&lt;/a&gt;, built it with llgo, and successfully loaded it into Google Chrome. I&amp;rsquo;d like to expand on this a little now, and describe how to build and run it.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;Before your start&amp;hellip;&lt;/b&gt;&lt;/h3&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;If you want to want to try this out yourself, then you&amp;rsquo;ll need to grab yourself a copy of the &lt;a href=&#34;https://developers.google.com/native-client/sdk/download&#34;&gt;Native Client SDK&lt;/a&gt;. I&amp;rsquo;ve only tested this on Ubuntu Linux 12.10 (x86-64), so if you&amp;rsquo;re trying this out on a different OS/arch you may need to alter the instructions.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Anyway, grab the SDK according to the instructions on the page I linked to above. Be sure to get the&amp;nbsp;devevelopment/unstable branch, by updating with the &amp;ldquo;pepper_canary&amp;rdquo; target:&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;$ cd nacl_sdk; ./naclsdk update pepper_canary&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;This is not a small download, so go and brew some tea, or just read on to see where we&amp;rsquo;re going with this.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;The anatomy of a PNaCl module&lt;/b&gt;&lt;/h3&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;span style=&#34;background-position: initial initial; background-repeat: initial initial;&#34;&gt;By now I guess you probably know what&lt;/span&gt;&lt;span style=&#34;background-position: initial initial; background-repeat: initial initial;&#34;&gt;Native Client is, &lt;/span&gt;&lt;span style=&#34;background-position: initial initial; background-repeat: initial initial;&#34;&gt;but if you don&amp;rsquo;t, I suggest you take a moment to read about it on the Google Developers (&lt;a href=&#34;https://developers.google.com/native-client/&#34;&gt;https://developers.google.com/native-client/&lt;/a&gt;) site.&lt;/span&gt;&lt;span style=&#34;background-position: initial initial; background-repeat: initial initial;&#34;&gt;&lt;/span&gt;What may not be so well known is PNaCl, the next evolution of Native Client. PNaCl (pronounced pinnacle), is short for &lt;i&gt;Portable&lt;/i&gt;&lt;i&gt;Native Client, &lt;/i&gt;and is based on LLVM.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Developers continue to write their code the same as in traditional NaCl, but now it is compiled to LLVM &lt;i&gt;bitcode; &lt;/i&gt;PNaCl restricts usage to a portable subset of bitcode so that it can then be translated to native x86, x86-64, or ARM machine code. To compile C or C++ modules to PNaCl/LLVM bitcode, one uses the pnacl-clang compiler provided with the Native Client SDK.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;To make use of Native Client, one develops a &lt;i&gt;module&lt;/i&gt;, which is an executable, that can be loaded into Google Chrome (or Chromium). A module implements certain functions specified in the Pepper API (&lt;i&gt;PPAPI&lt;/i&gt;), which is the API that interfaces your module with the browser. One of the functions is &lt;i&gt;PPP_InitializeModule&lt;/i&gt;, and another is &lt;i&gt;PPP_GetInterface&lt;/i&gt;. The former provides a function pointer to the module for calling back into the browser; the latter is invoked to interrogate the module for &lt;i&gt;i&lt;/i&gt;&lt;i&gt;nterfaces&lt;/i&gt;that it implements.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;A&lt;i&gt;&lt;/i&gt;&lt;i&gt;nacl/&lt;/i&gt;&lt;i&gt;ppapi&lt;/i&gt; package for Go&lt;/b&gt;&lt;/h3&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Since llgo speaks LLVM, it should be feasible to write PNaCl modules in Go, right? Right! So I set about doing this last week, and found that it was fairly easy to do. I have written a demo module which you can find here: &lt;a href=&#34;https://github.com/axw/llgo/tree/master/pkg/nacl/ppapi&#34;&gt;https://github.com/axw/llgo/tree/master/pkg/nacl/ppapi&lt;/a&gt;, which I later intend to morph into a reusable Go package, with a proper API. I have made a lot of shortcuts, and the code is not particularly idiomatic Go; bear in mind that llgo is still quite immature, and that this is mostly a proof of concept.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Most of the code in the package is scaffolding; the example module is mostly defined in &lt;i&gt;&lt;a href=&#34;https://github.com/axw/llgo/blob/master/llgo/testdata/programs/nacl/example.go&#34;&gt;example.go&lt;/a&gt;&lt;/i&gt;, some also in &lt;i&gt;&lt;a href=&#34;https://github.com/axw/llgo/blob/master/pkg/nacl/ppapi/ppapi.go&#34;&gt;ppapi.go&lt;/a&gt;&lt;/i&gt;. At the top of example.go, we instantiate a pppInstance1_1, which is a structure which defines the “Instance” interface. This interface is used to communicate the lifecycle of an instance of the module; when a module is loaded in a web page, then this interface is invoked. We care about when a module instance is created, and when it is attached to a &lt;i&gt;view&lt;/i&gt; (i.e. the area of the page which contains the module). Note that when I say interface, I mean a PPAPI interface, not a Go interface. Later, I hope to have modules implement Go interfaces, and hide the translation to PPAPI interfaces.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;The example is contrived, and quite simple; it demonstrates the use of the &lt;a href=&#34;https://developers.google.com/native-client/pepperc/struct_p_p_b___graphics2_d__1__0&#34;&gt;Graphics2D&lt;/a&gt; interface, which, as the name suggests, enables a module to perform 2D graphics operations. The demo simply draws repeating rectangles of different colours, animated by regularly updating the graphics context and shifting the pixels on each iteration. I would have used the standard “image” Go package, but unfortunately llgo is currently having trouble compiling it. I&amp;rsquo;ll look into that soon.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;Building llgo&lt;/b&gt;&lt;/h3&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;span style=&#34;background-position: initial initial; background-repeat: initial initial;&#34;&gt;Alright&lt;/span&gt;, how do we build this thing? We&amp;rsquo;re going to do the following things:&lt;/div&gt;&lt;ol&gt;&lt;li&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Build llgo,  and related tools.&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Compile the  PNaCl-module Go code into an LLVM module.&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Link the llgo  runtime into the module.&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Link the  ppapi library from the Native Client SDK into the module.&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Translate the  module into a native executable.*&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;em&gt;The final step is currently necessary, but eventually Chrome/Chromium will perform the translation in the browser.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Let&amp;rsquo;s begin by building the &lt;i&gt;llgo-dist&lt;/i&gt;tool. This will be used to build the llgo compiler, runtime, and linker. More on each of those in a moment. Go ahead and build llgo-dist:&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;i&gt;$ go get github.com/axw/llgo/cmd/llgo-dist&lt;/i&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;The llgo-dist tool takes two options: &lt;i&gt;-llvm-config, &lt;/i&gt;and &lt;i&gt;-triple&lt;/i&gt;. The former is the path to the &lt;i&gt;llvm-config&lt;/i&gt;tool, and defaults to simply “llvm-config” (i.e. find it using PATH). The latter is the LLVM target triple used for compiling the runtime package (and other core packages, like syscall). The Native Client SDK contains an llvm-config and the shared library that we need to link with to use LLVM&amp;rsquo;s C API.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;As I said above, I&amp;rsquo;m running on Linux x86-64, so for my case, the llvm-config tool can be found in:&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;i&gt;$ nacl_sdk/pepper_canary/toolchain/linux_x86_pnacl/host_x86&lt;em&gt;64/bin/llvm-config&lt;/i&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;At this point, you should put the “host&lt;/em&gt;&amp;lt;arch&amp;gt;/bin” directory in your PATH, and the “host_&amp;lt;arch&amp;gt;/lib” directory in your LD_LIBRARY_PATH, as llgo currently requires it, and I refer &lt;span style=&#34;background-position: initial initial; background-repeat: initial initial;&#34;&gt;to executables without their full paths &lt;/span&gt;&lt;span style=&#34;background-position: initial initial; background-repeat: initial initial;&#34;&gt;in some cases&lt;/span&gt;&lt;span style=&#34;background-position: initial initial; background-repeat: initial initial;&#34;&gt;.&lt;/span&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;The Native Client SDK creates shared libraries with the target &lt;i&gt;armv7-none-linux-gnueabi&lt;/i&gt;, so we&amp;rsquo;ll do the same. Let&amp;rsquo;s go ahead and build llgo now.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;i&gt;$ llgo-dist -triple=armv7-none-linux-gnueabi -llvm-config=nacl_sdk/pepper_canary/toolchain/linux_x86_pnacl/host_x86_64/bin/llvm-config&lt;/i&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;We now have a compiler, linker, and runtime. As an aside, on my laptop it took about 2.5s to build, which is great! The gc toolchain is a wonderful thing. You can safely ignore the warning about “different data layouts” when llgo-dist compiles the syscall package, as we will not be using the syscall package in our example.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;Building the example&lt;/b&gt;&lt;/h3&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Now, let&amp;rsquo;s compile the PNaCl module:&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;i&gt;$ llgo -c -o main.o -triple=armv7-none-linux-gnueabi llgo/pkg/nacl/ppapi/&lt;/em&gt;.go llgo/testdata/programs/nacl/example.go&lt;/i&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;This creates a file called “main.o”, which contains the LLVM bitcode for the module. Next, we&amp;rsquo;ll link in the runtime. Eventually, I hope that the “go” tool will be able to support llgo (I have hacked mine up to do this), but for now you&amp;rsquo;re going to have to do this manually.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;i&gt;$ llgo-link -o main.o main.o $GOPATH/pkg/llgo/armv7-none-linux-gnueabi/runtime.a&lt;/i&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Now we have a module with the runtime linked in. The llgo runtime defines things like functions for appending to slices, manipulating maps, etc. Later, it will contain a more sophisticated memory allocator, a garbage collector runtime, and a goroutine scheduler.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;We can&amp;rsquo;t translate this to a native executable yet, because it lacks an entry point. In a PNaCl module, the entry point is defined in a shared library called &lt;i&gt;libppapi_stub.a,&lt;/i&gt;&lt;i&gt;&lt;/i&gt;which is included by the libppapi.a linker script&lt;i&gt;. &lt;/i&gt;We can link this in using pnacl-clang, like so:&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;i&gt;$ pnacl-clang -o main.pexe main.o -lppapi&lt;/i&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;This creates a &lt;i&gt;portable executable&lt;/i&gt; (.pexe), an executable still in LLVM bitcode form. As I mentioned earlier, this will eventually be the finished product, ready to load into Chrome/Chromium. For now, we need to run a final step to create the native machine code executable:&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;i&gt;$ pnacl-translate -arch x86-64 -o main_x86_64.nexe main.pexe&lt;/i&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;That&amp;rsquo;s it. If you want to load this in an x86 or ARM system, you&amp;rsquo;ll also need to translate the pexe to an x86 and/or ARM nexe. Now we can run it.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;Loading the PNaCl module into Chrome&lt;/b&gt;&lt;/h3&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;I&amp;rsquo;m not sure at what point all the necessary parts became available in Chrome/Chromium, so I&amp;rsquo;ll just say what I&amp;rsquo;m running: I have added the Google Chrome PPA, and installed google-chrome-beta. This is currently at version 24.0.1312.35 beta.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;By default, Chrome only allows Native Client modules to load from the Chrome Web Store, but you can override this by mucking about in about:flags. Load up Chrome, go to about:flags, enable “Native Client”, and restart Chrome so the change takes effect. Curiously, there&amp;rsquo;s a “Portable Native Client” flag; it may be that the translator is already inside Chrome, but I&amp;rsquo;m not aware of how to use it.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://4.bp.blogspot.com/-N9-czi_nYd0/UMQWw9TEGLI/AAAAAAAACgQ/MMSbKuSrcsE/s1600/about_flags.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; height=&#34;183&#34; src=&#34;http://4.bp.blogspot.com/-N9-czi_nYd0/UMQWw9TEGLI/AAAAAAAACgQ/MMSbKuSrcsE/s320/about_flags.png&#34; width=&#34;320&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;To simplify matters, I&amp;rsquo;m going to hijack the hello_world example in the Native Client SDK. If you want to start from scratch, refer to the Native Client SDK documentation. So anyway we&amp;rsquo;ll build the hello_world example, then replace the executable with our own one.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;$ cd nacl_sdk/examples/hello_world&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;$ make pnacl/Release/hello_world.nmf&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;$ cp &amp;lt;path/to/&lt;i&gt;main_x86_64.nexe&lt;/i&gt;&lt;i&gt;&amp;gt; pnacl/Release/hello_world_x86_64.nexe&lt;/i&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Now start an HTTP server to serve this application (inside the hello_world directory):&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;$ python -m SimpleHTTPServer&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;i&gt;Serving HTTP on 0.0.0.0 port 8000 &amp;hellip;&lt;/i&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Finally, navigate to the following location:&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;a href=&#34;http://localhost:8000/index_pnacl_Release.html&#34;&gt;http://localhost:8000/index_pnacl_Release.html&lt;/a&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://2.bp.blogspot.com/-AUXuC0SqrEM/UMQOCol6U8I/AAAAAAAACgA/HB7Gh3UAEjI/s1600/go_pnacl.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; height=&#34;281&#34; src=&#34;http://2.bp.blogspot.com/-AUXuC0SqrEM/UMQOCol6U8I/AAAAAAAACgA/HB7Gh3UAEjI/s320/go_pnacl.png&#34; width=&#34;320&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm; margin-left: 1.25cm;&#34;&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Behold, animated bars! Obviously the example is awfully simplistic, but the I wanted to get this out so others can start playing with it. I&amp;rsquo;m not really in the business of fancy graphics, so I&amp;rsquo;ll leave more impressive demos to others.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;Next Steps&lt;/b&gt;&lt;/h3&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;I&amp;rsquo;ll keep dabbling with this, but my more immediate goals are to complete llgo&amp;rsquo;s general functionality. As wonderful as all of this is, it&amp;rsquo;s no good if the compiler doesn&amp;rsquo;t work correctly. Anyway, once I do get some more time for this, I intend to:&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Clean  up nacl/ppapi, providing  an  external API.&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Update llgo-link to transform a “main” function into a global  constructor (i.e. an “init” function) when compiling for PNaCl.&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Update  llgo-link to link in libppapi_stub.a when compiling for PNaCl, so we  don&amp;rsquo;t need to use pnacl-clang. Ideally  we should be able to “go build”, and have that immediately ready  to be loaded into Chrome.&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Get  the  image  package to build, and  update nacl/ppapi to use  it.&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;Implement  syscall  for PNaCl.  This  will probably involve calling standard POSIX C functions, like &lt;i&gt;read&lt;/i&gt;,  &lt;i&gt;write, mmap, &lt;/i&gt;etc.  Native Client code is heavily sandboxed, but  provides familiar POSIX APIs  to  do things like file I/O.&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;If you play around with this and produce something interesting, please let me know.&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;margin-bottom: 0cm;&#34;&gt;That&amp;rsquo;s all for now – have fun!&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>llgo update #10: &#34;hello, world!&#34; redux</title>
      <link>https://awilkins.id.au/post/blogger/llgo-update-10-hello-world-redux/</link>
      <pubDate>Sun, 25 Nov 2012 14:28:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/llgo-update-10-hello-world-redux/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s about time for another progress update on llgo. I&amp;rsquo;ve made decent progress recently, so let&amp;rsquo;s go through what&amp;rsquo;s new.&lt;br /&gt;&lt;br /&gt;&lt;h4&gt;Highlights&lt;/h4&gt;I&amp;rsquo;ve been refactoring bits of code and fixing bugs aplenty, so there is a mass of noise in the git commits. In terms of new function, the news is that we now have:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Type switches.&lt;/li&gt;&lt;li&gt;Type assertions.&lt;/li&gt;&lt;li&gt;Labeled statements; goto, labeled break and continue.&lt;/li&gt;&lt;li&gt;The &lt;a href=&#34;https://github.com/axw/llgo/tree/master/cmd/llgo-dist&#34;&gt;llgo-dist&lt;/a&gt; command; more on this below.&lt;/li&gt;&lt;li&gt;String conversions: to/from byte slices; from rune/int.&lt;/li&gt;&lt;li&gt;String range. I&amp;rsquo;m sure &lt;a href=&#34;https://github.com/axw/llgo/blob/master/pkg/runtime/strings.go#L77&#34;&gt;the implementation&lt;/a&gt;&amp;nbsp;could be improved.&lt;/li&gt;&lt;li&gt;Implemented &lt;a href=&#34;https://github.com/axw/llgo/blob/master/pkg/sync/atomic/atomic.ll&#34;&gt;sync/atomic&lt;/a&gt; using LLVM atomic operations intrinsics.&lt;/li&gt;&lt;li&gt;Various changes to enable linking multiple packages (e.g. exported symbols are now prefixed with their package path).&lt;/li&gt;&lt;li&gt;Additional support for floats (&lt;a href=&#34;https://github.com/axw/llgo/pull/11&#34;&gt;thanks to spate&lt;/a&gt;); partial support for complex numbers.&lt;/li&gt;&lt;li&gt;&amp;rdquo;&amp;hellip;args&amp;rdquo; calls to variadic functions (including slice append).&lt;/li&gt;&lt;li&gt;A self-contained runtime package. I have cloned (and slightly modified in some cases) the Go portion of the runtime package from gc, and combined it with the runtime code I had already written for llgo.&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/axw/llgo/blob/master/pkg/math/math.ll&#34;&gt;Bridge code for the math package,&lt;/a&gt; which mostly just redirects the exported functions to the internal, pure-Go implementations.&lt;/li&gt;&lt;li&gt;System calls (&lt;a href=&#34;https://github.com/axw/llgo/blob/master/pkg/syscall/syscall_linux_amd64.ll&#34;&gt;Linux/AMD64&lt;/a&gt; only so far).&lt;/li&gt;&lt;li&gt;Closures; more below.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;h4&gt;llgo-dist&lt;/h4&gt;&lt;div&gt;I have begun implementing a command that takes care of building llgo, its runtime, and in the future any other tools that might be considered part of llgo (e.g. an in-development linker). This tool will set up the cgo flags given the path to an &amp;ldquo;llvm-config&amp;rdquo; program, and build gollvm.&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;h4&gt;&lt;i&gt;reflect&lt;/i&gt;, &lt;i&gt;fmt&lt;/i&gt;, oh my!&lt;/h4&gt;&lt;br /&gt;Last week, &lt;a href=&#34;https://plus.google.com/u/0/102738380796586573408/posts/LDYxBXHXmHN&#34;&gt;I mentioned on Google+&lt;/a&gt;&amp;nbsp;that I managed to get the &lt;a href=&#34;http://golang.org/pkg/reflect&#34;&gt;reflect&lt;/a&gt;&amp;nbsp;package working. At least enough of it to get the &lt;a href=&#34;http://golang.org/pkg/fmt/&#34;&gt;fmt&lt;/a&gt;&amp;nbsp;package to work. At least enough of the fmt package to get fmt.Println(&amp;ldquo;Hello, world!&amp;rdquo;) to work&amp;hellip;&amp;nbsp;Yep, the holy grail of programming examples now compiles, links, and runs, using llgo. This demonstrates the following things work:&lt;br /&gt;&lt;br /&gt;&lt;ol&gt;&lt;li&gt;Compilation of the following packages:&amp;nbsp;errors, io, math, os, reflect, runtime, strconv, sync, sync/atomic, syscall, time, unicode/utf8, unsafe.&lt;/li&gt;&lt;li&gt;Package imports (still using the gcimporter from exp/types.)&lt;/li&gt;&lt;li&gt;Linking multiple compiled packages using llvm-link.&lt;/li&gt;&lt;li&gt;Interfaces and reflection (fmt.Println uses reflection to determine the underlying type).&lt;/li&gt;&lt;li&gt;System calls (fmt.Println will eventually issue a system call to write to the stdout file).&lt;/li&gt;&lt;/ol&gt;&lt;br /&gt;&lt;h4&gt;Closures&lt;/h4&gt;Yes indeed, we now have closures. &lt;a href=&#34;https://github.com/axw/llgo/blob/master/literals.go#L70&#34;&gt;The code&lt;/a&gt; is pretty hackish, so I expect it&amp;rsquo;s not very solid. I have implemented them using LLVM&amp;rsquo;s trampoline intrinsics. Essentially you provide LLVM with a function that takes N parameters, give it a block of (executable) memory and an argument to bind, and it fills in the block with function code for a function with N-1 parameters (the Nth one being bound).&lt;br /&gt;&lt;br /&gt;Unfortunately I have found that the closures are not playing nicely with lli/JIT, which means the closure unit test I have written fails. If I compile it with llc/gcc, though, it works just fine. So either I&amp;rsquo;ve done something subtly stupid, or the JIT is clobbering something it shouldn&amp;rsquo;t. As far as I got with debugging was finding that the bound argument value is wrong when the function is entered.&lt;br /&gt;&lt;br /&gt;I expect I&amp;rsquo;ll probably replace this implementation for a couple of reasons:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Portability: I&amp;rsquo;d rather avoid platform-specific code like this.&amp;nbsp;For one thing, the &lt;a href=&#34;http://www.chromium.org/nativeclient/pnacl/bitcode-abi&#34;&gt;PNaCl ABI&lt;/a&gt;&amp;nbsp;calls out trampoline intrinsics as being unsupported.&lt;/li&gt;&lt;li&gt;Testability: I should investigate the problems I observed with lli/JIT further, and I&amp;rsquo;m loath to change implementation to support tests, it is a real problem. I rely heavily on tests to make sure I haven&amp;rsquo;t broken anything.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;Until I find out that using trampolines has a marked benefit to performance in real programs, I intend to replace the current implementation with one that uses a pair of pointers for functions. The bound argument will stored in one pointer, and the function pointer in another. This has implications for all function calls, though it should be simple to achieve good performance in most cases.&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;h4&gt;What&amp;rsquo;s next?&lt;/h4&gt;&lt;div&gt;Haven&amp;rsquo;t figured this one out yet. I have been meaning to play more with PNaCl, so I might take some time now to do that. I expect I&amp;rsquo;ll be slowing down development considerably early 2013, as (a) we&amp;rsquo;re knocking down our place and rebuilding, and (b) my second child is on the way. I hope to have llgo in a better state for contributions by then, so others can pick up the slack.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;I expect in the near future I&amp;rsquo;ll start playing with clang/cgo integration, as I start playing with PNaCl. I&amp;rsquo;ll write back when I have something to demonstrate.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Until then.&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>llgo update, milestone</title>
      <link>https://awilkins.id.au/post/blogger/llgo-update-milestone/</link>
      <pubDate>Sun, 09 Sep 2012 18:26:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/llgo-update-milestone/</guid>
      <description>&lt;p&gt;In between gallivanting in &lt;a href=&#34;http://en.wikipedia.org/wiki/Sydney&#34;&gt;Sydney&lt;/a&gt;, working, and organising to have a new house built, I&amp;rsquo;ve squeezed in a little bit of work on llgo. If you&amp;rsquo;ve been following along on Github, you&amp;rsquo;ll have seen that things have progressed a bit since last time I wrote.&lt;br /&gt;&lt;br /&gt;Aside from a slew of bug fixes and trivialities, llgo now implements:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Slice operations (make, append, slice expressions). I&amp;rsquo;ve only implemented single-element appends so far, i.e. No &lt;i&gt;append(s, a, b, c, &amp;hellip;)&lt;/i&gt; or &lt;i&gt;(s, abc&amp;hellip;)&lt;/i&gt; yet.&lt;/li&gt;&lt;li&gt;Named results in functions.&lt;/li&gt;&lt;li&gt;Maps - creation, indexing, assignment, and deletion. The underlying implementation is just a dumb linked-list at this point in time. I&amp;rsquo;ll implement it as a hash map in the future, when there aren&amp;rsquo;t more important things to implement.&lt;/li&gt;&lt;li&gt;Range statements for arrays, slices and maps. I haven&amp;rsquo;t done strings yet, simply because it requires a bit more thought into iterating through strings runes-at-a-time. I don&amp;rsquo;t expect it&amp;rsquo;ll be too much work.&lt;/li&gt;&lt;li&gt;Branch statements, except for goto. You can now break, continue, and fallthrough.&lt;/li&gt;&lt;li&gt;String indexing, and slicing.&lt;/li&gt;&lt;li&gt;Function literals. Once upon a time these were working, but they haven&amp;rsquo;t been for a while. Now they are again. Note that this does not include support for closures at this stage, so usefulness is pretty limited.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Early on in the development of llgo, I decided that rather than implementing the compiler by going through the specification one item at a time, I&amp;rsquo;d drive the development by attempting to compile a real program. For this, I chose &lt;a href=&#34;https://code.google.com/p/go/source/browse/src/pkg/unicode/maketables.go&#34;&gt;maketables&lt;/a&gt;, a program from the &lt;i&gt;unicode&lt;/i&gt;&amp;nbsp;standard library package. As of today, llgo can successfully compile the program. That is, it compiles that specific&amp;nbsp;&lt;i&gt;file,&lt;/i&gt; maketables.go. It doesn&amp;rsquo;t yet compile all of its dependencies, and it certainly doesn&amp;rsquo;t link or produce a usable program.&lt;br /&gt;&lt;br /&gt;So now I&amp;rsquo;ll be working towards getting all of the dependencies compiling, then linking. In the interest of seeing usable progress, I think I might now take a bottom-up approach and start focusing on the core libraries, like &lt;i&gt;runtime&lt;/i&gt; and &lt;i&gt;syscall&lt;/i&gt;. I&amp;rsquo;ll report back when I have something interesting to say.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gocov, llgo update</title>
      <link>https://awilkins.id.au/post/blogger/gocov-llgo-update/</link>
      <pubDate>Sat, 21 Jul 2012 22:09:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/gocov-llgo-update/</guid>
      <description>&lt;p&gt;I guess it&amp;rsquo;s time for a quick update. I&amp;rsquo;m not very diligent with this blogging thing; too busy having fun, programming. Sorry about that!&lt;br /&gt;&lt;br /&gt;&lt;h3&gt; Introducing gocov&lt;/h3&gt;A couple of weeks ago I &lt;a href=&#34;https://groups.google.com/d/topic/golang-nuts/abujHqfUbvo/discussion&#34;&gt;announced &lt;/a&gt;&lt;a href=&#34;http://github.com/axw/gocov&#34;&gt;gocov&lt;/a&gt;, a coverage testing tool for the Go programming language. I wrote gocov to quickly get an idea of how broadly tested packages are (namely exp/types, which I&amp;rsquo;m working on in the background). The tool itself is written in Go, and works by source instrumentation/transformation. Currently gocov only does statement coverage.&lt;br /&gt;&lt;br /&gt;Using gocov is relatively simple (if I do say so myself). First, you install gocov by running:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&#34;background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); color: #333333; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace; font-size: 13px; line-height: 19px; margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;&#34;&gt;&lt;code style=&#34;background-color: transparent; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: none; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace; font-size: 12px; margin: 0px; padding: 0px;&#34;&gt;go get github.com/axw/gocov/gocov&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;This will install the gocov tool into your $GOPATH/bin directory. Once you have it installed, you can test a package (i.e. run its tests, and generate coverage data), by running:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&#34;background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); color: #333333; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace; font-size: 13px; line-height: 19px; margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;&#34;&gt;&lt;code style=&#34;background-color: transparent; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: none; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace; font-size: 12px; margin: 0px; padding: 0px;&#34;&gt;gocov test &amp;lt;path/to/package&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;Under the covers, this will run &amp;ldquo;go test &amp;lt;path/to/package&amp;gt;&amp;rdquo;, after having gone through the process of instrumenting the source. Once the tests are complete, gocov will output the coverage information as a JSON structure to stdout. So you might want to pipe that output somewhere&amp;hellip;&lt;br /&gt;&lt;br /&gt;Once you&amp;rsquo;ve got the coverage information, you&amp;rsquo;ll probably want to view it. So there are two other gocov commands: report, and annotate. The &lt;i&gt;report&lt;/i&gt; command will generate a text report of the coverage of all the functions in the coverage information provided to it. For example:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&#34;background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); color: #333333; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace; font-size: 13px; line-height: 19px; margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;&#34;&gt;&lt;code style=&#34;background-color: transparent; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: none; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace; font-size: 12px; margin: 0px; padding: 0px;&#34;&gt;gocov test github.com/axw/llgo/types | gocov report&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;&amp;hellip; will generate a report that looks something like:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&#34;background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;&#34;&gt;&lt;span style=&#34;color: #333333; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace;&#34;&gt;&lt;span style=&#34;font-size: 12px; line-height: 18px;&#34;&gt;&amp;hellip;&lt;br /&gt;types/exportdata.go      readGopackHeader              69.23% (&lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;13&lt;/sub&gt;)&lt;br /&gt;types/gcimporter.go      gcParser.expect               66.67% (&lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;6&lt;/sub&gt;)&lt;br /&gt;types/gcimporter.go      gcParser.expectKeyword        66.67% (&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;)&lt;br /&gt;&amp;hellip;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;The &lt;i&gt;annotate&lt;/i&gt;&amp;nbsp;command will print out the source for a specified function, along with an annotation for each line that was missed. For example:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&#34;background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); color: #333333; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace; font-size: 13px; line-height: 19px; margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;&#34;&gt;&lt;code style=&#34;background-color: transparent; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: none; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace; font-size: 12px; margin: 0px; padding: 0px;&#34;&gt;gocov test github.com/axw/llgo/types | gocov annotate - types.gcParser.expectKeyword&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;&amp;hellip; will output the following:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&#34;background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;&#34;&gt;&lt;span style=&#34;color: #333333; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace;&#34;&gt;&lt;span style=&#34;font-size: 12px; line-height: 18px;&#34;&gt;266             func (p &lt;em&gt;gcParser) expectKeyword(keyword string) {&lt;br /&gt;267                     lit := p.expect(scanner.Ident)&lt;br /&gt;268                     if lit != keyword {&lt;br /&gt;269 MISS                        p.errorf(&amp;ldquo;expected keyword %s, got %q&amp;rdquo;, keyword, lit)&lt;br /&gt;270                     }&lt;br /&gt;271             }&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;br /&gt;As is often the case when I write software, I wrote gocov for my own needs; as such it&amp;rsquo;s not terribly featureful, only doing what I&amp;rsquo;ve needed thus far. If you would like to add a feature (maybe HTML output, or branch coverage), feel free to send a pull request on the &lt;a href=&#34;http://github.com/axw/gocov&#34;&gt;Github repository&lt;/a&gt;, and I&amp;rsquo;ll take a gander.&lt;br /&gt;&lt;br /&gt;Anyway, I hope it&amp;rsquo;s of use to people. But not too many people, I don&amp;rsquo;t have time to fix all of my crappy code! (Just kidding, I have no life.)&lt;br /&gt;&lt;br /&gt;&lt;h3&gt; Update on llgo: interface comparisons, exp/types&lt;/h3&gt;I don&amp;rsquo;t have a lot to report on this front, as I&amp;rsquo;ve been doing various other things, like that stuff up there, but I can share a couple of bits of mildly interesting news.&lt;br /&gt;&lt;br /&gt;I&amp;rsquo;ve been working a little on the runtime for llgo, and I&amp;rsquo;m proud to say there&amp;rsquo;s now an initial implementation of interface comparison in the runtime. This involved filling in the algorithm table for runtime types, implementing the runtime equality function (runtime.memequal), and implementing a runtime function (runtime.compareI2I) to extract and call it. It probably doesn&amp;rsquo;t sound exciting when put like that, but this is something of a milestone.&lt;br /&gt;&lt;br /&gt;By the way, if you want to actually use the runtime, you can do it like this:&lt;br /&gt;&lt;br /&gt;&lt;ol&gt;&lt;li&gt;Compile your program with llgo, storing the bitcode in file &lt;i&gt;x.ll&lt;/i&gt;.&lt;/li&gt;&lt;li&gt;Compile llgo/runtime/&lt;/em&gt;.go with llgo, storing the bitcode in file &lt;i&gt;y.ll&lt;/i&gt;.&lt;/li&gt;&lt;li&gt;Link the two together, using llvm-link: &lt;i&gt;llvm-link -o z.ll x.ll y.ll&lt;/i&gt;&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;And you&amp;rsquo;re done. The resultant module, housed in&amp;nbsp;&lt;i&gt;z.ll&lt;/i&gt;, contains your program and the llgo runtime. Now you can concatenate strings and compare interfaces to your heart&amp;rsquo;s content. Eventually llgo will contain an integrated linker, which will rewrite symbol names according to package paths.&lt;/div&gt;&lt;div&gt;&lt;i&gt;&lt;br /&gt;&lt;/i&gt;&lt;/div&gt;&lt;br /&gt;Finally, on exp/types: I submitted my first two CL&amp;rsquo;s. Some of my ideas for exp/types were ill thought out, so the first was rejected (fairly), and the second needs some rework. I&amp;rsquo;ll be writing up a design proposal document at some stage, to better document my rationale for changes. Anyway, I&amp;rsquo;ll keep plugging away&amp;hellip;&lt;br /&gt;&lt;br /&gt;Ade!&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unit-testing llgo&#39;s runtime</title>
      <link>https://awilkins.id.au/post/blogger/unit-testing-llgos-runtime/</link>
      <pubDate>Sun, 03 Jun 2012 15:53:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/unit-testing-llgos-runtime/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s been a while since I last wrote, primarily because I&amp;rsquo;ve been moving house and was without Internet at home during the process. It&amp;rsquo;s back now, but now I have Diablo III to contend with.&lt;br /&gt;&lt;br /&gt;In my &lt;a href=&#34;http://blog.awilkins.id.au/2012/04/llgo-runtime-emerges.html&#34;&gt;previous post&lt;/a&gt; I mentioned that I would create a new branch for working on the &lt;a href=&#34;http://github.com/axw/llgo&#34;&gt;llgo &lt;/a&gt;runtime. I haven&amp;rsquo;t done that yet, though I haven&amp;rsquo;t broken the build either. Rather, I&amp;rsquo;ve introduced conditional compilation to &lt;a href=&#34;http://github.com/axw/gollvm&#34;&gt;gollvm &lt;/a&gt;for builds against LLVM&amp;rsquo;s trunk where unreleased functionality is required, e.g. LinkModules. This isn&amp;rsquo;t currently being used in llgo-proper, so I&amp;rsquo;ve gotten away without branching so far.&lt;br /&gt;&lt;br /&gt;The tag for building gollvm with unreleased functions is &amp;ldquo;llvmsvn&amp;rdquo;, so to build gollvm with LLVM&amp;rsquo;s trunk, including the LinkModules function, do the following:&lt;br /&gt;&lt;pre style=&#34;background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); color: #333333; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace; font-size: 13px; line-height: 19px; margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;&#34;&gt;&lt;code style=&#34;background-color: transparent; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: none; font-family: &#39;Bitstream Vera Sans Mono&#39;, Courier, monospace; font-size: 12px; margin: 0px; padding: 0px;&#34;&gt;curl &lt;a href=&#34;https://raw.github.com/axw/gollvm/master/install.sh&#34;&gt;https://raw.github.com/axw/gollvm/master/install.sh&lt;/a&gt; -tags llvmsvn | sh&lt;/code&gt;&lt;/pre&gt;So I didn&amp;rsquo;t break &amp;ldquo;the build&amp;rdquo;, meaning you can still build gollvm/llgo without also building LLVM from source. I did, however, break the llgo unit tests, as they are using the new LinkModules function. If you want to run the unit tests without building LLVM from source, then you can comment out the call to &lt;i&gt;llvm.LinkModules&lt;/i&gt;&amp;nbsp;in llgo/utils_test.go&lt;i&gt;; &lt;/i&gt;of course, you should&amp;nbsp;expect failures due to the runtime not being linked in, but that doesn&amp;rsquo;t involve all tests.&lt;br /&gt;&lt;br /&gt;What else is new?&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://groups.google.com/d/msg/golang-dev/aYZM61-ySUs/qVjKlt1WtWAJ&#34;&gt;I announced on golang-dev a couple of weeks ago&lt;/a&gt; that I intend to work on getting exp/types up to snuff. I&amp;rsquo;ve moved some of the type construction code out of llgo-proper into llgo/types (a fork of exp/types), and eliminated most of the llgo-specific stuff from llgo/types. I&amp;rsquo;ll need to set aside some time soon to learn how to use Mercurial and create some changelists.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;A few weeks ago I started &lt;a href=&#34;https://plus.google.com/u/0/102738380796586573408/posts/GibftVAePRW&#34;&gt;playing with llgo and PNaCl&lt;/a&gt;, to see how hard it would be to get something running in Chrome. It works (with the IR Translator/external sandbox anyway), but then llgo doesn&amp;rsquo;t really do much at the moment.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;That&amp;rsquo;s all for now.&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An llgo runtime emerges</title>
      <link>https://awilkins.id.au/post/blogger/an-llgo-runtime-emerges/</link>
      <pubDate>Sat, 28 Apr 2012 15:44:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/an-llgo-runtime-emerges/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s been a long time coming, but I&amp;rsquo;m now starting to put together pieces of the llgo runtime. Don&amp;rsquo;t expect much any time soon, but I am zeroing in on a design at least.&amp;nbsp;The sleuths in the crowd will find that only string concatenation has been implemented thus far, which is pretty boring. Next up, I hope, will be interface-to-interface conversions, and interface-to-value conversions, both of which require (for a sane implementation) a runtime library.&lt;br /&gt;&lt;br /&gt;I had previously intended to write the runtime largely in C, as I expected that would be the easiest route. I started down this road writing a basic thread creation routine using pthread, written in C. The code was compiled using &lt;a href=&#34;http://clang.llvm.org/&#34;&gt;Clang&lt;/a&gt;, emitting LLVM IR which could be easily linked with the code generated by llgo. It&amp;rsquo;s more or less the same idea implemented by the gc Go compiler (linking C and Go code, not relying on pthread). Even so, I&amp;rsquo;d like to write the runtime in Go as much as possible.&lt;br /&gt;&lt;br /&gt;Why write the runtime in Go? Well for one, it will make llgo much more self contained, which will make distribution much easier since there won&amp;rsquo;t be a reliance on Clang. Another reason is based on a lofty, but absolutely necessary goal: that llgo will one day be able to compile itself. If llgo compiles itself, and compiles its own runtime, then we have a great target for compiler optimisations: the compiler itself. In other words, &lt;a href=&#34;http://prog21.dadgum.com/136.html&#34;&gt;&amp;ldquo;compiler optimisations should pay for themselves.&amp;rdquo;&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;In my last post I mentioned that LLVM 3.1 is coming up fast, and this release has the changes required by llgo. Unfortunately, I&amp;rsquo;ve just found that the C API lacks an interface for linking modules, so I&amp;rsquo;m going to have to submit a patch to LLVM again, and the window for inclusion in 3.1 has certainly passed. Rather than break gollvm/llgo&amp;rsquo;s trunk again, I&amp;rsquo;ll create a branch for work on the runtime. I&amp;rsquo;ll post again when I&amp;rsquo;ve submitted a patch to LLVM, assuming the minor addition is accepted.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>llgo update: Go1, automated tests</title>
      <link>https://awilkins.id.au/post/blogger/llgo-update-go1-automated-tests/</link>
      <pubDate>Sun, 08 Apr 2012 21:44:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/llgo-update-go1-automated-tests/</guid>
      <description>&lt;p&gt;This week I finished up&amp;nbsp;&lt;a href=&#34;http://www.udacity.com/overview/Course/cs373&#34;&gt;Udacity CS373: Programming a Robotic Car&lt;/a&gt;, and also &lt;i&gt;finally &lt;/i&gt;finished reading &lt;a href=&#34;http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach&#34;&gt;GEB&lt;/a&gt;. So I&amp;rsquo;ll hopefully be able to commit some more time to llgo again.&lt;br /&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;I moved on to Go&amp;rsquo;s weekly builds a while back, and updated both llgo and gollvm to conform. I&amp;rsquo;m now on Go 1, as I hope most people are by now, and llgo is in good shape for Go 1 too. That&amp;rsquo;s not to say that it compiles all of the Go 1 language, just that it runs in Go 1. Apart from that, I&amp;rsquo;ve just been working through some sample programs to increase the compiler&amp;rsquo;s capability.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;One of the things that I&amp;rsquo;ve been a bit lazy about with llgo is automated testing, something I&amp;rsquo;m usually pretty keen on. I&amp;rsquo;ve grown anxious over regressions as time has gone on in the development, so I&amp;rsquo;ve spent a little bit of time this week putting together an automated test suite, which I &lt;a href=&#34;https://groups.google.com/d/topic/golang-nuts/s_EehtIclUY/discussion&#34;&gt;mentioned in golang-nuts&lt;/a&gt; a few days ago. The test suite doesn&amp;rsquo;t cover a great deal yet, but it has picked up a couple of bugs already.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;One of the numerous things I like about Go is its well integrated tooling. For testing, Go provides the &lt;a href=&#34;http://golang.org/pkg/testing&#34;&gt;testing&lt;/a&gt;&amp;nbsp;package, and &lt;a href=&#34;http://golang.org/cmd/go/#Test_packages&#34;&gt;go test&lt;/a&gt;&amp;nbsp;tool. So you write your unit tests according to the specifications in the &amp;ldquo;testing&amp;rdquo; package, run &amp;ldquo;go test&amp;rdquo;, and your tests are all run. This is comparable to, say, Python, which has a similar &amp;ldquo;unittest&amp;rdquo; package. It is vastly more friendly than the various C++ unit test frameworks; that&amp;rsquo;s in large part due to the way the Go language is designed, particularly with regard to how it fits into build systems and is parsed.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;In Go, everything you need to build a package is in the source (assuming you use the &amp;ldquo;go&amp;rdquo; command).&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;The only external influences on the build process (environment variables GOOS, GOARCH, GOROOT, etc.) apply to the entire build procedure, not to single compilation units. Each variant will end up in a separate location when built: ${GOPATH}/pkg/${GOOS}_${GOARCH}/&amp;lt;pkgname&amp;gt;.&lt;/li&gt;&lt;li&gt;Platform-specific code is separated into multiple files (xxx_linux.go, xxx_windows.go, &amp;hellip;), and they&amp;rsquo;re automatically matched with the OS/architecture by the &amp;ldquo;go&amp;rdquo; command.&lt;/li&gt;&lt;li&gt;Package dependencies are automatically and unambiguously resolved. Compare this with C/C++ headers, which might come from anywhere in the preprocessor&amp;rsquo;s include path.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;So anyway, back to llgo&amp;rsquo;s testing. It works just like this: I&amp;rsquo;ve created a separate program for each test case in the &lt;span style=&#34;font-family: &#39;Courier New&#39;, Courier, monospace;&#34;&gt;llgo/llgo/testdata&lt;/span&gt;&amp;nbsp;directory. Each of these programs corresponds to a test case written against the &amp;ldquo;testing&amp;rdquo; package, which does the following:&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;ol&gt;&lt;li&gt;Run the program using &amp;ldquo;go run&amp;rdquo;, and store the output.&lt;/li&gt;&lt;li&gt;Redirect stdout to a pipe, and run a goroutine to capture the output to a string.&lt;/li&gt;&lt;li&gt;Compile the program using llgo&amp;rsquo;s Compile API, and then interpret the resultant bitcode using gollvm&amp;rsquo;s ExecutionEngine API.&lt;/li&gt;&lt;li&gt;Restore the original stdout, and compare the output with that of the original &amp;ldquo;go run&amp;rdquo;.&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;Pretty obvious I guess, but I was happy with how easy it was to do. Defer made the job of redirecting, restoring and closing file descriptors pain free; the go statement and channels made capturing and communicating the resulting data a cinch.&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;This is getting a little ramble-ish, so I&amp;rsquo;ll finish up. While testing, I discovered a problem with the way LLVM types are generated from &lt;i&gt;types.Type&lt;/i&gt;&amp;rsquo;s, which basically means that they need to be cached and reused, rather that generated afresh each time. At the same time I intend to remove all references to LLVM from my clone of the &amp;ldquo;types&amp;rdquo; package, and offer my updates back to the Go team. It&amp;rsquo;s not fully functional yet, but there&amp;rsquo;s at least a few gaps that I&amp;rsquo;ve filled in.&lt;br /&gt;&lt;br /&gt;One last thing: LLVM 3.1 is due out May 14, so gollvm and llgo will no longer require LLVM from SVN. I really want to eliminate the dependency on llvm-config from the build of gollvm. I&amp;rsquo;m considering a dlopen/dlsym shim and removing the cgo dependency on LLVM. I&amp;rsquo;d be keen to hear some opinions, suggestions or alternatives.&lt;br /&gt;&lt;br /&gt;Until next time.&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Imports in llgo, jr.</title>
      <link>https://awilkins.id.au/post/blogger/imports-in-llgo-jr./</link>
      <pubDate>Sun, 19 Feb 2012 13:50:00 +0000</pubDate>
      
      <guid>https://awilkins.id.au/post/blogger/imports-in-llgo-jr./</guid>
      <description>&lt;p&gt;So I realised I&amp;rsquo;m a doofus the other day, when I started getting closer to completion on producing export metadata in llgo. Rolling my own import mechanism is unnecessary for now. Instead, I can just lean on the import mechanism that exists in the standard library (well, &lt;a href=&#34;http://weekly.golang.org/doc/go1.html#exp&#34;&gt;until Go 1&lt;/a&gt; at least): go/types/GcImporter.&lt;br /&gt;&lt;br /&gt;I&amp;rsquo;ve modified llgo to use go/ast/NewPackage, rather than the old code I had that was using go/parser/ParseFiles. The NewPackage function takes an optional &amp;ldquo;importer&amp;rdquo; object which will be used for inter-package dependency resolution, whereas ParseFiles does no resolution. The standard GcImporter type may be used to identify exports by interrogating the object and archive files in $GOROOT. The AST that&amp;rsquo;s generated is filled in with external declarations, so it&amp;rsquo;s then up to llgo to convert those into LLVM external declarations. Easy peasy.&lt;br /&gt;&lt;br /&gt;Now it&amp;rsquo;s time to come up with a symbol naming scheme. Without having thought about it too hard, I&amp;rsquo;m going to start off with the assumption that the absolute name of the symbol (package+name), with slashes converted to dots, will do the trick. Once I&amp;rsquo;ve implemented that, I&amp;rsquo;ll need to start work on the runtime in earnest. It&amp;rsquo;s also high time I put some automated tests in place, since things are starting to get a little stabler.&lt;br /&gt;&lt;br /&gt;In the long term I&amp;rsquo;ll probably want to continue on with my original plan, which is to generate module-level metadata in the LLVM bitcode, and then extract this in a custom importer. It should be quite straightforward.&amp;nbsp;Earlier this week I wrapped up some updates to gollvm to add an API to make generating &lt;a href=&#34;http://llvm.org/docs/SourceLevelDebugging.html&#34;&gt;source-level debugging metadata&lt;/a&gt; simpler. This will be useful not only for describing exports, but also for what it&amp;rsquo;s intended: generating &lt;a href=&#34;http://dwarfstd.org/&#34;&gt;DWARF&lt;/a&gt;&amp;nbsp;debug information.&lt;br /&gt;&lt;br /&gt;In other news: my wife just ordered the 1-4a box set of&amp;nbsp;&lt;a href=&#34;http://www-cs-staff.stanford.edu/~uno/taocp.html&#34;&gt;The Art of Computer Programming&lt;/a&gt;&amp;nbsp;for me. At the moment I am slowly making way through&amp;nbsp;&lt;a href=&#34;http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach&#34;&gt;Gödel, Escher, Bach: an Eternal Golden Braid&lt;/a&gt;, and so far, so good. Looking forward to more light reading for the bus/train!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>