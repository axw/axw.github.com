<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>awilkins.id.au</title>
<link rel="stylesheet" href="https://awilkins.id.au//css/style.css">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/github.min.css">


<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
	
	<a class="nav-item" href="https://awilkins.id.au/">
	<h1 class="title is-4" style="color: #666666; font-weight: bold">
	a<span style="color:#4a83d4; font-weight: bold">wilkins</span>.id.<span style="color:#4a83d4; font-weight: bold">au</span>
	</h1>
	</a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/axw">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/yayxw">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
          <a class="level-item" href="/index.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/writing-a-compiler-or-learning-a-language-the-hard-way/">Writing a Compiler, or Learning a Language the Hard Way</a></h1>
      <div class="content">
        <p>For a while now I&rsquo;ve been lamenting the lack of progress in systems programming languages. I work primarily in C++ (professionally, anyway), a language which leaves a lot to be desired. The end result, assuming you know what you&rsquo;re doing, is likely to be fast code. But getting there can be a tedious and precarious journey. Don&rsquo;t get me wrong, I&rsquo;m not a C++ hater. I just think we can do better.<br /><br />So for the past few I&rsquo;ve been&nbsp;storing away ideas for writing my own language. (<i>Groan,&nbsp;another one</i>.) The vast majority of languages these days seem to be JVM based, or some other VM such as the CLR. This is fine for many applications, but for a lot of systems programming you typically want to be much closer to the hardware. What I want is something with the ease and rapidity of development of, say, Python, with the power of a lower-level language such as C/C++.<br /><br /><b><span class="Apple-style-span" style="font-size: large;"><br /></span></b><br /><b><span class="Apple-style-span" style="font-size: large;">The Easy: Ideas</span></b><br /><br />So what are those ideas I&rsquo;d stored away then? Well to be honest, many of them boil down to syntactic sugar (syntactic caramel?), so here are the more functional ones:<br /><br /><ul><li><b>Implicit Interfaces</b>. The idea is that classes should be able to implement an interface without explicitly saying so, just by implementing the methods defined in the interface. Poor-man&rsquo;s duck-typing if you will.</li><li><b>Link Time Optimisation (LTO)</b> should be the norm. Say you write a function in a library which does everything and the kitchen sink. If the calling program only uses a function from your library in a certain way, then the function should be optimised for that usage.</li><li><b>Pure Functions.</b>&nbsp;This kind of fits under LTO. I want simpler meta-programming: it should be possible to mark functions as being &ldquo;pure&rdquo;, which means (in my terminology) that the function either has no side-effects, or affects only temporary variables. Calls to these functions could then be evaluated at compile time, e.g. to calculate complex mathematical expressions. I guess this just comes under &ldquo;fancy optimiser&rdquo;?</li><li><b>Pattern Matching.</b>&nbsp;I haven&rsquo;t really fleshed this one out, but I think it would be handy to be able to match functions not just based on signature, but based on the values of the arguments.</li><li><b>No preprocessor, no headers. </b>When code is distributed, the modules should be self describing, such as with Java&rsquo;s compiled .class files. This would eliminate problems such as compiling against an old version of an interface, and linking against a new, incompatible implementation.</li><li><b>For the love of God, no garbage collection.</b>&nbsp;What can I say? I like my <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>.</li><li>I&rsquo;m not really sure what title to give this one, but I wanted to eliminate the problems you get with linking objects together that have been compiled with different options in C++ (e.g. with/out RTTI, exceptions, or perhaps against an entirely different STL/standard library.)</li></ul>There were some other requirements I had in mind, such as having a single reference implementation&nbsp;à&nbsp;la CPython, and including a parser with the runtime to simplify tool development.<br /><div><br /></div><div><b><span class="Apple-style-span" style="font-size: large;"><br /></span></b></div><div><b><span class="Apple-style-span" style="font-size: large;">The Hard: Writing a Compiler</span></b></div><div><b><span class="Apple-style-span" style="font-size: large;"><br /></span></b></div><div>Anyone can come up with ideas. Even coming up with practical ideas isn&rsquo;t too hard, but implementing them is something else altogether. Especially so for someone like me who has had no formal education in compilers, or language design/implementation. Hell, my university course didn&rsquo;t even cover formal grammars or parsing. I&rsquo;ve picked some things up by myself, but it&rsquo;s a very academic field.</div><div><br /></div><div>Back when I was in uni, I toyed around with&nbsp;<a href="http://www.cminusminus.org/">C&ndash;</a>, which at the time looked like quite a promising &ldquo;portable assembly language&rdquo;. This language is (or at least was) used as the intermediate language for the <a href="http://www.haskell.org/ghc/">Glasgow Haskell Compiler</a>. My self-taught knowledge of language design/implementation and code generation were not really up to scratch, so I didn&rsquo;t get much further than writing toy languages.</div><div><br /></div><div>Fast forward a few years, and I&rsquo;ve got the itch to implement a compiler again. I&rsquo;ve recently been playing around with LLVM. It boasts a relatively easy to use API, which takes out some of the drudgery of writing the &ldquo;bitcode&rdquo; (an intermediate code that can be translated to machine code). I&rsquo;ve got a bit more knowledge and programming skill behind my belt now, so let&rsquo;s get to work on that language, right!?</div><div><br /></div><div>I read something recently which is summarised as: learn intimately that which you wish to replace. Now I don&rsquo;t have any illusions of replacing any existing language, but I think the message is still relevant. I&rsquo;ve never implemented a language OR a compiler before, and now I&rsquo;m going to both at once? How about I make this a bit easier on myself, and write a compiler for an existing language. If I still want to implement my own language later, I can use the experience I gained.</div><div><br /></div><div>I&rsquo;ve been looking for an excuse for a while now to learn the&nbsp;<a href="http://www.golang.org/">Go Programming Language</a>. It has some of the same design goals as my hypothetical language, so it seemed like a good fit.</div><div><br /></div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;"><b>The Fun: Learning Go and LLVM</b></span></div><div><span class="Apple-style-span" style="font-size: large;"><b><br /></b></span></div><div>I&rsquo;ve been learning Go in my precious spare time for the last couple of weeks. There&rsquo;s a nifty web-app which provides an interactive tutorial in Go, called <a href="http://go-tour.appspot.com/">A Tour of Go</a>. It&rsquo;s a bit of fun, and I recommend it to anyone wanting to learn the language.</div><div><br /></div><div>So anyway, I&rsquo;m now playing around with writing a Go compiler using LLVM. Why?</div><div><ul><li>To learn LLVM, and more generally how to write a compiler and generate code.</li><li>To learn Go.</li><li>Potentially to fill a gap in JIT compilation of Go programs.</li><li>Why not?</li></ul><div>Writing the compiler will be made much easier by the fact that the Go runtime includes a Go parser, and someone has already implemented <a href="https://github.com/nsf/gollvm">Go bindings for LLVM</a>. I haven&rsquo;t made a great deal of progress yet, but it seems achievable. When I&rsquo;ve got something vaguely useful, I&rsquo;ll chuck it over on GitHub.</div></div><div><br /></div><div>If you know anything about Go, you&rsquo;ll probably have noticed that at least one of the ideas that I presented above is present in Go: implicit interfaces. I really can&rsquo;t say whether this concept is new or not - it&rsquo;s probably not - but I did at least come up with it independently. Just sayin&rsquo;!</div><div><br /></div><div>I&rsquo;ll write a follow-up post when I get some time, describing a bit more about the Go compiler, the challenges I&rsquo;ve come across, and my thoughts on how to solve them.&nbsp;</div></p>

      </div>
      <h2 class="subtitle is-6">
      Posted October 23, 2011.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/c-source-to-source-translation/">C&#43;&#43; Source-to-Source Translation</a></h1>
      <div class="content">
        <p>I&rsquo;ve been on annual leave this week, so I&rsquo;ve taken the opportunity to do some work on <a href="http://github.com/axw/cmonster">cmonster</a>. I&rsquo;ve added preliminary support for source-to-source translation by introducing a wrapper for Clang&rsquo;s &ldquo;Rewriter&rdquo; API. My fingers have been moving furiously so it&rsquo;s all a bit rough, but it does work.<br /><br />The API flow is:<br /><br /><ol><li>Parse translation unit, returning an Abstract Syntax Tree (AST).</li><li>Walk AST to find bits of interest.</li><li>Insert/replace/erase text in the original source, using the location stored in each declaration/statement/token.</li></ol><div><b><span class="Apple-style-span" style="font-size: large;"><br /></span></b></div><div><b><span class="Apple-style-span" style="font-size: large;">Motivating Example</span></b></div><div><b><br /></b></div><div>Logging is a necessary evil in complex software, especially when said software is running on a customer&rsquo;s system, inaccessible to you. To make problem determination easier, we want a decent amount of information: file names, line numbers, function names, time of day, thread ID, &hellip; but all of this comes at a cost. I&rsquo;m not talking just cost in terms of CPU usage, though that is a major concern. I&rsquo;m talking cost in terms of source code quality and maintainability.</div><div><br /></div><div>We&rsquo;ll start off with a trivial C program:</div><div><br /></div><div><pre class="prettyprint lang-c">int main(int argc, const char *argv[])<br />{<br />    if (argc % 2 == 0)<br />    {<br />        return 1;<br />    }<br />    else<br />    {<br />        return 0;<br />    }<br />}<br /></pre></div><div><br /></div><div>Let&rsquo;s say our needs are fairly humble: we just want to log the entry and exit of this function. Logging entry is easy: add a blob of code at the top of the function. We can get the function name and line number using <strong>func</strong> (C99, C++11) and <strong>LINE</strong>. What about <strong>func</strong> in C89? C++98? There&rsquo;s various alternatives, but some compilers have nothing. And that makes writing a cross-platform logging library a big old <a href="http://en.wikipedia.org/wiki/Pain_in_the_ass">PITA</a>.&nbsp;The information is there in the source code - if only we could get at it! In the end, we&rsquo;re more likely to forego <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>, and just reproduce the function name as a string literal.</div><div><br /></div><div>Getting the function name and line number isn&rsquo;t a huge problem, but how about adding function exit logging? Now we&rsquo;re going to have to insert a little bit of code before our return statements. So we&rsquo;ll have something like:</div><div><br /></div><div><pre class="prettyprint lang-c">int main(int argc, const char *argv[])<br />{<br />    const char *function = &ldquo;main&rdquo;;<br />    printf(&ldquo;Entering %s:%s:%d\n&rdquo;, function,<br />           <strong>FILE</strong>, <strong>LINE</strong>);<br />    if (argc % 2 == 0)<br />    {<br />        printf(&ldquo;Leaving %s:%s:%d\n&rdquo;, function,<br />               <strong>FILE</strong>, <strong>LINE</strong>);<br />        return 1;<br />    }<br />    else<br />    {<br />        printf(&ldquo;Leaving %s:%s:%d\n&rdquo;, function,<br />               <strong>FILE</strong>, <strong>LINE</strong>);<br />        return 0;<br />    }<br />    return 0;<br />}<br /></pre></div><div><b><br /></b></div><div>Ugh. And that&rsquo;s just the start. It gets much nastier when we need to turn logging on/off at runtime, filter by function name, etc. We could make it much nicer with a variadic macro. Something like LOG(format&hellip;), which calls a varargs function with the &lsquo;function&rsquo; variable, <strong>FILE</strong>, <strong>LINE</strong> and the format and arguments you specify. Unfortunately variadic macros are not supported by some older compilers. The first version of Visual Studio to support them was Microsoft Visual Studio 2005. So there goes that idea&hellip;</div><div><br /></div><div>Hmmm, what to do, what to do? Wouldn&rsquo;t it be nice if we could just tag a function as requiring entry/exit logging, and have our compiler toolchain to the work? Entry/exit logging is the sort of thing you want to be consistent, so it should suffice to define one set of rules that covers all functions. Let&rsquo;s take a little peek at what we could do with cmonster.<br /><br />First, we&rsquo;ll parse the source to get an AST. We&rsquo;ll locate all functions defined in the main file, and insert an &ldquo;Entry&rdquo; logging statement at the beginning of the body, and an &ldquo;Exit&rdquo; logging statement before each return statement in the body. At the end we dump the rewritten source to stdout, and we have a program, with logging, ready to be compiled.</div><div><br /></div><div><script src="https://gist.github.com/1269367.js?file=add_logging.py"></script></div><div><br /></div><div>Tada! Running this, we&rsquo;re given: <br /><br /><pre class="prettyprint lang-c">#include &lt;stdio.h&gt;<br />int main(int argc, const char *argv[])<br />{<br />    printf(&ldquo;Entering main at line 2\n&rdquo;);<br />    if (argc % 2 == 0)<br />    {<br />        printf(&ldquo;Returning from main at line 6\n&rdquo;);<br />        return 1;<br />    }<br />    else<br />    {<br />        printf(&ldquo;Returning from main at line 10\n&rdquo;);<br />        return 0;<br />    }<br />}</pre></div><div><br /></div><div><b><span class="Apple-style-span" style="font-size: large;">Future Work</span></b></div><div><br /></div><div>What we can&rsquo;t do yet is insert, replace, erase or modify declarations or statements directly in the AST, and have that reflected as a text insertion/replacement/erasure. For example, maybe I want to rename a function? Why can&rsquo;t I just go &ldquo;function_declaration.name = &lsquo;new_name&rsquo;&ldquo;. At the moment we&rsquo;d need to replace the text identified by a source range&hellip; a bit clunky and manual. So&nbsp;I may add a more direct API in at a later stage. It should be doable, but may be a lot of work.</div><div><br />Also, the Visitor class defined in the above example could be called minimal at best. If there were any statements in the code that weren&rsquo;t handled by our visitor, the translation program would barf. I&rsquo;ll eventually build a complete Visitor class into cmonster to be reused. This should make writing translation tools a breeze; in our example, we would just override &ldquo;visit_ReturnStatement&rdquo; in the visitor.<br /><br />Now, I think it&rsquo;s about time I learnt <a href="http://golang.org/">Go</a>.</div></p>

      </div>
      <h2 class="subtitle is-6">
      Posted October 7, 2011.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/cmonster-update/">cmonster update</a></h1>
      <div class="content">
        <p><br />I&rsquo;ve been quietly beavering away at <a href="http://github.com/axw/cmonster">cmonster</a>, and thought I should share an update.<br /><br /><b>Note: </b>the changes I describe below are not yet part of a cmonster release. I&rsquo;ll release something once I&rsquo;ve stabilised the API and tested it more thoroughly. In the mean time you can pull the source from github.<br /><br />In the last month or so I have been adding C/C++ parsing capabilities to cmonster, by exposing the underlying Clang parser API. I&rsquo;ve been wanting a simple, scriptable framework for analysing and manipulating C++ source for a few years now. The reason for wanting such a thing is so that I, and others, can more rapidly develop tools for writing better C++, and eliminate some of the drudgery. I&rsquo;ve only just made a start, but cmonster now provides an API for parsing a C/C++ source file, returning a Python object to inspect the result.<br /><br />So what&rsquo;s cmonster looking like now? We now have a preprocessor and a parser interface, the former now being incorporated into the latter. The parser interface will parse a single source file, and return its Abstract Syntax Tree (AST). As is typical with parsers, there are many classes involved to describe each declaration, statement, type, etc. So I&rsquo;ve added <a href="http://cython.org/">Cython </a>into the mix to speed up the process of defining Python equivalents for each of these classes.<br /><br />Unfortunately Cython does not yet support <a href="http://www.python.org/dev/peps/pep-0384/">PEP 384</a> (Py_LIMITED_API), so at the moment cmonster is back to requiring the full Python API, and thus must be rebuilt for each new release. I&rsquo;ve had a tinker with Cython to get its output to compile with Py_LIMITED_API, and hope to provide a patch in the near future.<br /><br />What&rsquo;s next? Once I get the AST classes mapped out, I intend to introduce a source-to-source translation layer. I&rsquo;m not entirely sure how this&rsquo;ll work yet, but I think ideally you&rsquo;d just modify the AST and call some function to rewrite the main source file. Elements of the AST outside of the main source file would be immutable. That&rsquo;s the hope, but it may end up being something a little more crude, using Clang&rsquo;s &ldquo;Rewriter&rdquo; interface directly to replace source ranges with some arbitrary string. I expect this will be a ways off yet, though.</p>

      </div>
      <h2 class="subtitle is-6">
      Posted September 25, 2011.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/hello-mr.-hooker./">Hello, Mr. Hooker.</a></h1>
      <div class="content">
        <p>I&rsquo;ve been procrastinating on <a href="http://github.com/axw/cmonster">cmonster</a>.&nbsp;I have some nasty architectural decisions to make, and I keep putting it off. In the mean time I&rsquo;ve been working on a new little tool called &ldquo;Mr. Hooker&rdquo; (or just <a href="http://github.com/axw/mrhooker">mrhooker</a>).<br /><br /><b>Introducing Mr. Hooker</b><br /><br />The idea behind mrhooker is very simple: I wanted to be able to write LD_PRELOAD hooks in Python. If you&rsquo;re not familiar with LD_PRELOAD, it&rsquo;s a mechanism employed by various UNIX and UNIX-like operating systems for &ldquo;preloading&rdquo; some specified code in a shared library. You can use this to provide your own version of native functions, including those in standard libraries such as libc.<br /><br />Anyway, I occasionally find the need for an LD_PRELOAD library to change the behaviour of a program that I can&rsquo;t easily recompile. Often these libraries will be throw-away, so it might end up taking just as long to write the LD_PRELOAD library. So I wrote mrhooker to simplify this.<br /><br />It turns out there&rsquo;s very little to do, since <a href="http://cython.org/">Cython </a>(and friends) do most of the hard work. Cython is a programming language that extends Python to simplify building Python extensions. It also has an interface for building these extensions on-the-fly. So mrhooker doesn&rsquo;t need to do much - it takes a .pyx (Pyrex/Cython source) and compiles it to a shared library using Cython. Mrhooker takes this, and some common code, and loads it into a child process using LD_PRELOAD.<br /><br /><b>Example - Hooking BSD Sockets</b><br /><b><br /></b><br />Let&rsquo;s look at an example of how to use mrhooker. Hooks are defined as external functions in a Cython script.&nbsp;Say we want to hook the BSD sockets &ldquo;send&rdquo; function. First we&rsquo;d find the signature of send (man 2 send), which is:<br /><br /><pre class="prettyprint">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</pre><br />Given this, we can produce a wrapper in Cython, like so:<br /><br /><pre class="prettyprint">cdef extern ssize_t send(int sockfd, char *buf, size_t len, int flags) with gil:<br />    &hellip;<br /></pre><br />There&rsquo;s a couple of important things to note here. First, the parameter type for &ldquo;buf&rdquo; drops const, since Cython doesn&rsquo;t know about const-ness. Second, and crucially, the function must be defined &ldquo;with gil&rdquo;. This ensures that the function acquires the Python Global Interpreter Lock before calling any Python functions. Okay, with that out of the way, let&rsquo;s go on&hellip;<br /><br />We&rsquo;ll want to do something vaguely useful with this wrapper. Let&rsquo;s make it print out the argument values, and then continue on with calling the original &ldquo;send&rdquo; function. To do that we&rsquo;ll use dlsym/RTLD_NEXT to find the next function called &ldquo;send&rdquo;.<br /><br /><pre class="prettyprint">cdef extern ssize_t send(int sockfd, char <em>buf, size_t len, int flags) with gil:<br />    print &ldquo;====&gt; send(%r, %r, %r, %r)&rdquo; % (sockfd, buf[:len], len, flags)<br />    real_send = dlsym(RTLD_NEXT, &ldquo;send&rdquo;)<br />    if real_send:<br />        with nogil:<br />            res = (&lt;ssize_t(</em>)(int, void<em>, size_t, int) nogil&gt;real_send)(<br />                sockfd, buf, len, flags)<br />        return res<br />    else:<br />        return -1<br /></pre><br />We&rsquo;ll also need to declare dlsym and RTLD_NEXT. Let&rsquo;s do that.<br /><br /><pre class="prettyprint"># Import stuff from &lt;dlfcn.h&gt;<br />cdef extern from &ldquo;dlfcn.h&rdquo;:<br />    void</em> dlsym(void<em>, char</em>)<br />    void* RTLD_NEXT<br /></pre><br />Now you just run:<br /><br /><pre class="prettyprint lang-bash">mrhooker &lt;script.pyx&gt; &lt;command&gt;<br /></pre><br /><br />And there we go. This is trivial - it would also be fairly trivial to write a C program to do this. But if we wanted to do anything more complex, or if we were frequently changing the wrapper function, I&rsquo;d much rather write it in Python - or Cython, as it were.<br /><br />Enjoy!<br /><br /><hr /><b>Edit:</b> I just noticed that it&rsquo;s broken if you don&rsquo;t have a certain config file. I always had one while testing&hellip; until I got to work.<br />You&rsquo;ll get an error &ldquo;ConfigParser.NoSectionError: No section: &lsquo;default&rsquo;&ldquo;. I&rsquo;ll fix the code at home, but in the mean time you can do this:<br /><br /><pre class="prettyprint lang-bash">$ mkdir ~/.mrhooker<br />$ echo [default] &gt; ~/.mrhooker/mrhooker.config<br /></pre><br />P.S. if you add &ldquo;build_dir = &lt;path&gt;&rdquo; in that section, or a per-module section, mrhooker/Cython will store the shared library that it builds. Then if you don&rsquo;t change the source it&rsquo;ll be used without rebuilding.</p>

      </div>
      <h2 class="subtitle is-6">
      Posted September 5, 2011.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/google-app-engine-agent/">Google App Engine Agent</a></h1>
      <div class="content">
        <p>A couple of months ago I wrote about <a href="http://blog.awilkins.id.au/2011/07/controlling-remote-agents-from-google.html">my foray into the world of Google App Engine</a>. More recently, I&rsquo;d gotten the itch again, and had some ideas of how to fix the problems I found when attempting to get <a href="http://awilkins.id.au/pushy/">Pushy </a>to work in&nbsp;Google App Engine.<br /><br />The root of most of the problems is that&nbsp;Google App Engine&nbsp;is stateless in nature. Server instances can be spun up or spun down without notice, and so we can&rsquo;t store complex state, which Pushy really requires. So a couple of weeks ago I set to investigating implementing a server-initiated RPC mechanism that is asynchronous and (mostly) stateless.<br /><br />How would it work? Well, earlier this year I read that <a href="http://googleappengine.blogspot.com/2011/04/introducing-protorpc-for-writing-app.html">ProtoRPC was released</a>, which brought RPC services to Google App Engine. In our case, Google App Engine is the client, and is calling the agent - but we can at least reuse the API to minimise dependencies and hopefully simplify the mechanism. Okay, so we have a ProtoRPC service running on a remote machine, consumed by our Google App Engine application. How do they talk?<br /><br />One thing I wanted to avoid was the need for polling, as that&rsquo;s both slow and expensive. Slow in that there will necessarily be delays between polls, and expensive in that unnecessary polls will burn CPU cycles in Google App Engine, which aren&rsquo;t free. Long-polling isn&rsquo;t possible, either, since HTTP requests are limited to 30 seconds of processing time. If you read my last post, you probably already know what I&rsquo;m going to say: we&rsquo;ll use XMPP.<br /><br />What&rsquo;s XMPP? That&rsquo;s the <a href="http://xmpp.org/">Extensible Messaging and Presence Protocol</a>, which is the protocol underlying Jabber. It is also the primary protocol that Google Talk is built on. It&rsquo;s an XML-based, client-server protocol, so peers do not talk directly to each other. It&rsquo;s also asynchronous. So let&rsquo;s look at the picture so far&hellip;<br /><br /><ul><li>The client (agent) and server (GAE application) talk to each other via XMPP.</li><li>The agent serves a ProtoRPC service, and the GAE application will consume it.</li></ul><div>Because our RPC mechanism will be server-initiated, we&rsquo;ll need something else: agent availability discovery. Google App Engine provides XMPP handlers for agent availability (and unavailability) notification. When an agent starts up it will register its presence with the application. When agent is discovered, the application will request the agent&rsquo;s service descriptor. The agent will respond, and the application will store it away in Memcache.</div><div><br /></div><div>We (ab)use Memcache for sharing of data between instances of the application. When you make enough requests to the application, Google App Engine may dynamically spin up a new instance to handle requests. By storing the service descriptor in Memcache, it can be accessed by any instance. I said abuse because Memcache is not guaranteed to keep the data you put in it - it may be expelled when memory is constrained. Really we should use Datastore, but I was too lazy to deal with cleaning it up. &ldquo;Left as an exercise for the reader.&rdquo; One thing I did make a point of using was to use the <a href="http://goo.gl/cWCFe">new Python Memcache CAS API</a>, which allows for safe concurrent updates to Memcache.</div><div><br /></div><div>Orrite. So now we have an agent and application which talk to each other via XMPP, using ProtoRPC. The application discovers the agent, and, upon request, the agent describes its service to the application. How can we use it? Well the answer is really &ldquo;however you like&rdquo;, but I have created a toy web UI for invoking the remote service methods.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-zkjIreamSFI/Tl-XUqoJCcI/AAAAAAAAA5E/NABDROL0wmM/s1600/gaea-ui.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="184" src="http://4.bp.blogspot.com/-zkjIreamSFI/Tl-XUqoJCcI/AAAAAAAAA5E/NABDROL0wmM/s320/gaea-ui.png" width="320" /></a></div><div><br /></div><div>Wot &lsquo;ave we &lsquo;ere then? The drop-down selection has all of the available agent JIDs (XMPP IDs). The textbox has some Python code, which will be executed by the Google App Engine application. Yes, security alert! This is just a demonstration of how we can use the RPC mechanism - not a best practice. When you hit &ldquo;Go!&rdquo;, the code will be run by the application. But before doing so, the application will set a local variable &ldquo;agent&rdquo;, which is an instance of the ProtoRPC service stub bound to the agent selected in the drop-down.</div><div><br /></div><div>ProtoRPC is intended to be synchronous (from the looks of the comments in the code, anyway), but there is an asynchronous API for clients. But given that application requests can only take up to 30 seconds to service a request, our application can&rsquo;t actively wait for a response. What to do? Instead, we need to complete the request asynchronously when the client responds, and convey some context to the response handler so it knows what to do with it.</div><div><br /></div><div>In the demo, I&rsquo;ve done something fairly straight forward with regards to response handling. When the UI is rendered, we create an asynchronous channel using the Channel API. We use this to send the response back to the user. So when the code is executed, the service stub is invoked, and the channel ID is passed as context to the client. When the client responds, it includes the context. Once again, security alert. We could fix security concerns by encrypting the context to ensure the client doesn&rsquo;t tamper with it. Let&rsquo;s just assume the client is friendly though, okay? Just this once!</div><div><br /></div><div>So we finally have an application flow that goes something like this:</div><div><ol><li>Agent registers service.</li><li>Server detects agent&rsquo;s availability, and requests client&rsquo;s service descriptor.</li><li>Client sends service descriptor, server receives and stores it in Memcache.</li></ol></div><div>and then&hellip;</div><div><ol><li>User hits web UI, which server renders with a new channel.</li><li>User selects an agent and clicks &ldquo;Go!&rdquo;.</li><li>Server instantiates a service stub, and invokes it with the channel ID as context. The invocation sends an XMPP message to the agent.</li><li>Agent receives XMPP message, decodes and executes the request. The response is sent back to the server as an XMPP message, including the context set by the server.</li><li>The server receives the response, and extracts the response and channel ID (context). The response is formatted and sent to the channel.</li><li>The web UI&rsquo;s channel Javascript callback is invoked and the response is rendered.</li></ol></div><div><br /></div><div style="text-align: center;"><b><i>Fin</i></b></div><div><br /></div><div>I&rsquo;ve put my code up on GitHub, here:&nbsp;<a href="http://github.com/axw/gaea">http://github.com/axw/gaea</a>.&nbsp;Feel free to fork and/or have a play.&nbsp;I hope this can be of use to someone. If nothing else, I&rsquo;ve learnt a few new tricks!</div></p>

      </div>
      <h2 class="subtitle is-6">
      Posted September 1, 2011.
      Tags: <a href="/tags/google-app-engine">google app engine</a>, <a href="/tags/python">python</a>, <a href="/tags/rpc">rpc</a>, <a href="/tags/xmpp">xmpp</a>.
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/its-alive/">It&#39;s Alive!</a></h1>
      <div class="content">
        <div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-jl8Gc0mJxhs/Tjo8xWNN1GI/AAAAAAAAA3Q/b5uOaYDRV98/s1600/Its_Alive.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-jl8Gc0mJxhs/Tjo8xWNN1GI/AAAAAAAAA3Q/b5uOaYDRV98/s1600/Its_Alive.jpg" /></a></div><br />I've been quietly hacking away on <a href="http://github.com/axw/cmonster"><b>cmonster</b>&nbsp;</a>(née csnake). I like this name even more: I think it describes my creation better. If you thought preprocessors were horrible before, well...<br /><br /><br /><span class="Apple-style-span" style="font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; font-size: large;"><b>What is cmonster?</b></span><br /><br />cmonster is a C preprocessor with a few novel features on top of the standard fare:<br /><br /><ul><li>Allows users to define function macros in Python, inline.</li><li>Allows users to define a callback for locating #include files, when the file can not be found in the specified include directories.</li><li>Provides a Python API for iterating over tokens in the output stream.</li></ul><div>cmonster is built on top of <a href="http://clang.llvm.org/">Clang</a>, a modern C language family compiler, which contains a reusable, programmable preprocessor. At present, cmonster requires Clang 3.0 APIs, which has not yet been released. I have been working off Clang's subversion trunk.</div><div><br /></div><div>I have just uploaded a binary distribution of the <a href="http://pypi.python.org/pypi/cmonster/0.1">first alpha version (0.1) of cmonster</a> to pypi. I have only built/tested it on Linux 32-bit, Python 3.2, and I don't expect it will work on anything else yet. If you want to play around with it, you can install cmonster using "easy_install cmonster" or by grabbing it off pypi and installing it manually.<br /><br /><br /><span class="Apple-style-span" style="font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; font-size: large;"><b>Demonstration</b></span><br /><br />Seeing is believing - how does this thing work? We'll ignore everying except for inline Python macros for now, because that's the most stable part of the API.<br /><br /><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">It is possible to define macros inline in cmonster, using the builtin "py_def" macro. For example:</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><pre class="brush:py" style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">py_def(factorial(n))<br />    import math<br />    return str(math.factorial(int(str(n))))<br />py_end<br /></pre><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">When cmonster sees this, it will grab everything up to "py_end", and define a Python function. It will also create a preprocessor macro with the function's name (as given in the py_def heading), and this macro will be directed to call the Python function.&nbsp;The Python function will be passed the argument tokens that the macro was invoked with. It can return either a sequence of tokens, or a string that will subsequently be tokenised.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div></div><div><br /></div><div><span class="Apple-style-span" style="font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; font-size: large;"><b>Addressing Shortcomings</b></span></div><div><br /></div><div>In my<a href="http://blog.awilkins.id.au/2011/06/c-preprocessor-macros-in-python.html"> previous post about csnake</a>&nbsp;I mentioned a few things that needed to be done. I have addressed some of these things in cmonster:<br /><br /></div><blockquote><span class="Apple-style-span" style="font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px;"><i>A way of detecting (or at least configuring) pre-defined macros and include paths for a target compiler/preprocessor. A standalone C preprocessor isn't worth much. It needs to act like or delegate to a real preprocessor, such as GCC.</i></span></blockquote>&nbsp;I have added support for emulating GCC. This is done by consulting GCC for its predefined macros (using "gcc -dM"), and using the new "include locator" callback feature. By setting an include locator callback on a cmonster preprocessor, you provide cmonster with a second-chance attempt at locating an include file when the file can not be found in the specified include directories. This method can be used to determine GCC's system include directories: whenever we can't find an include file, we consult GCC and add parse the output to determine the location of the file on disk. I intend to add support for more (common) compilers/preprocessors in the future. Namely, MSVC.<br /><br />I had another crazy idea for (ab)using include locators: handling specially formatted #include directives to feed off-disk files into the preprocessor. Buh? I mean, say, the ability to pull down headers from a hosted repository such as github (e.g. #include &lt;github.yourproject/header.h&gt;), and feeding them into the preprocessor as in-memory files. Or generating headers on the fly (e.g. #include &lt;myapi.proto&gt;, to automatically generate and include <a href="http://code.google.com/p/protobuf/">Protobuf</a> headers).<br /><br /><blockquote><span class="Apple-style-span" style="font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px;"><i>A #pragma to define Python macros in source, or perhaps if I'm feeling adventurous, something like #pydefine.</i></span></blockquote>Support for inline Python macros has been implemented: see the "Demonstration" section above. It's unlikely I'll attempt to create a #pydefine, as it would be more work than it's worth.<br /><br /><br /><blockquote><span class="Apple-style-span" style="font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px;"><i>A simple command line interface with the look and feel of a standard C preprocessor</i></span></blockquote>The distribution now contains a "cmonster" script, which invokes the preprocessor on a file specified on the command-line. This will need a lot of work: presently you can't add user include directories or (un)define macros. Neither of these things are difficult to add, they just haven't been top priorities.<br /><br /><br /><b><span class="Apple-style-span" style="font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; font-size: large;">Future Work</span></b><br /><div><br /></div>Still remaining to do (and sticking out like sore thumbs) are unit-tests and documentation. Now that I've got something vaguely usable, I will be working on those next.<br /><div><br /></div><div>Once I've tested, documented and stabilised the API, I'll look at (in no definite order):</div><div><ul><li>Improvement the command line interface. Add the standard "-I", "-D" and "-U" parameters.</li><li>Portability. Probably Windows first, since it's common and I have access to it.</li><li>Emulation of additional preprocessors.</li><li>Passing in-memory files ("file like" Python objects) to #include.</li></ul></div>

      </div>
      <h2 class="subtitle is-6">
      Posted August 4, 2011.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/controlling-remote-agents-from-google-app-engine/">Controlling Remote Agents from Google App Engine</a></h1>
      <div class="content">
        <p>A month or so ago I was brainstorming ideas related to <a href="http://code.google.com/appengine/">Google App Engine</a> (GAE), as I had been wanting a reason to play with it for a while. One idea that stuck was connecting a remote Python process to GAE via <a href="http://awilkins.id.au/pushy">Pushy</a>, so we could either control GAE or GAE could control the remote process. I&rsquo;m still working on the C/Python Preprocessor thingy, but I took a break from that this weekend to look into the possibility of a GAE Pushy transport.<br /><br />So yesterday morning I signed up for an account, and started tinkering. I had been reading the docs already, and I figured there were a few possible approaches:<br /><br /><ul><li>The obvious: use HTTP. This has one major drawback in that it is inherently synchronous and wholly driven by the client. Moreover, GAE only allows request handlers around 30s to complete, so no kind of fancy long-polling is possible here.</li><li>Channel API. This sounds like the right kind of thing to use, but it&rsquo;s aimed at interacting with Javascript in a webpage.</li><li>XMPP. Huh? Isn&rsquo;t that for instant messaging? Exactly. The client (remote Python process) and server (GAE) are peers in XMPP, and either one can initiate sending messages to the other. Let&rsquo;s look into this a bit more&hellip;</li></ul><div>So I did a quick search for Python XMPP libraries, and a few came up. I settled on <a href="http://xmpppy.sourceforge.net/">xmpppy</a>, but to be honest I didn&rsquo;t find any of them particularly compelling. The APIs are a bit clunky. Anyway, the approach I took was to have an XMPP handler in my GAE application create a persistent Pushy connection object associated with a pair of read/write files that wrapped the XMPP API. When an XMPP message came in, the application would extract the Pushy request from base-64 encoded body of the message, and return the result in a similar manner.</div><div><br /></div><div>And it worked, but only just. I had to make a few hacks to Pushy to get all of this work. There were some oddities I had to work around, such as the &ldquo;eval&rdquo; built-in in GAE&rsquo;s Python not taking any keyword arguments. Unfortunately, I don&rsquo;t think this particular transport is very useful in the flaky state it&rsquo;s in at the moment. Also, it&rsquo;s not terribly valuable to build a transport to control a GAE application, since other APIs&nbsp;exist for that purpose&nbsp;(<a href="http://code.google.com/appengine/docs/python/tools/protorpc/">ProtoRPC</a>, <a href="http://code.google.com/appengine/articles/remote_api.html">remote_api</a>). More useful would be to have the GAE application control the remote process without the need for polling. I&rsquo;ll be looking into this further.</div></p>

      </div>
      <h2 class="subtitle is-6">
      Posted July 17, 2011.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/le-sigh/">Le sigh</a></h1>
      <div class="content">
        <p>I&rsquo;ve been coming across more problems with Boost Wave. The current ones blocking me are:<br /><ul><li>A lack of an efficient way to conditionally disable a macro. The &ldquo;context policy&rdquo; provides hooks for handling macro expansions, and its return value is meant to control whether the expansion takes place. It doesn&rsquo;t work. I&rsquo;ll write up a bug report when I get some time.</li><li>Wave isn&rsquo;t very forgiving about integer under/overflow. For example, the GNU C library&rsquo;s header &ldquo;/usr/include/bits/wchar.h&rdquo; has the following tidbit to determine the sign of wide characters, which Boost Wave barfs on:</li></ul><pre class="brush:c">#elif L&rsquo;\0&rsquo; - 1 &gt; 0</pre><br /><div>I think the latter &ldquo;problem&rdquo; might actually be reasonable - I believe the standards say that handling of overflow is undefined, and preprocessor/compiler-specific. That doesn&rsquo;t help me much though. I could fix this by writing code to parse the expressions, which seems silly, or by passing off to the target preprocessor (e.g. GCC), which seems like overkill.<br /><br />I&rsquo;m going to have a look at how hard it would be to use LLVM/Clang&rsquo;s preprocessor instead. If that&rsquo;s a better bet, I may go that way. Otherwise, it might be time to get approval to send patches to the Wave project.</div></p>

      </div>
      <h2 class="subtitle is-6">
      Posted June 21, 2011.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/inline-python-macros-in-c/">Inline Python macros in C</a></h1>
      <div class="content">
        <p>I had a bit of time today to do some more work on that which is soon to be called something other than csnake. I&rsquo;ve added a couple of features:<br /><br /><ul><li>You can now define custom pragmas, providing a Python handler function. Unfortunately Boost Wave, which csnake uses for preprocessing, only provides callbacks for pragmas that start with &ldquo;#pragma wave&rdquo;.</li><li>Built-in pragmas and macros to support defining Python macros inline in C/C++ code.</li><li>A <strong>main</strong> program in the csnake package. So you can now do &ldquo;python3.2 -m csnake <source file=""></source>&rdquo;, which will print out the preprocessed source.</li></ul><div>So for example, you can do something like as follows, entirely in one C++ file:</div><br /><div><pre class="brush:c++">// factorial macro.<br />py_def(factorial(n))<br />    import math<br />    f = math.factorial(int(str(n)))<br />    return [Token(T_INTLIT, f)]<br />py_end<br /><br />int main()<br />{<br />    std::cout &lt;&lt; factorial(3) &lt;&lt; std::endl;<br />    return 0;<br />}<br /></pre></div><div><br />This works as follows: <i>py_def</i> and <i>py_end</i>&nbsp;are macros, which in turn use the _Pragma operator with built-in pragmas. Those pragmas are handled by csnake, and signal to collect the tokens in between. When the py_end macro is reached, the tokens are concatenated and a Python function macro is born.<br /><br />I&rsquo;m intending to do additonal &ldquo;Python blocks&rdquo;, including at least a <i>py_for</i>&nbsp;block, which will replicate the tokens within the block for each iteration of a loop.<br /><br />There&rsquo;s one big problem with the <i>py_def</i>&nbsp;support at the moment, which is that the tokens go through the normal macro replacement procedure. I think I&rsquo;ll have a fix for that soon.</div></p>

      </div>
      <h2 class="subtitle is-6">
      Posted June 18, 2011.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/name-clash/">Name clash</a></h1>
      <div class="content">
        <p>Rats, looks like I didn&rsquo;t do enough homework on the name &ldquo;csnake&rdquo;. Turns out there&rsquo;s another Python-based project called CSnake:&nbsp;<a href="https://github.com/csnake-org/CSnake/">https://github.com/csnake-org/CSnake/</a>. Incidentally - and not that it matters much - I had the name picked out before that project was released. Now I need to think up another puntastic name.</p>

      </div>
      <h2 class="subtitle is-6">
      Posted June 15, 2011.
      
      </h2>
    </article>
    
  </div>
</section>

<section class="section">
  <div class="container">
    <nav class="level is-mobile">
      <div class="level-left">
        <div class="level-item">
          
          <a class="button" href="/page/2/">
            <span class="icon is-small is-marginless">
              <i class="fa fa-angle-left"></i>
            </span>
            Newer
          </a>
          
        </div>
      </div>
      <div class="level-right is-marginless">
        <div class="level-item">
          
          <a class="button" href="/page/4/">
            Older
            <span class="icon is-small is-marginless">
              <i class="fa fa-angle-right"></i>
            </span>
          </a>
          
        </div>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container has-text-centered">
    <p></p>
  </div>
</section>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/go.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/python.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-17223840-3', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>



