
<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Posts | awilkins.id.au</title>
<link rel="stylesheet" href="https://awilkins.id.au//css/style.css">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/github.min.css">


<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
	
	<a class="nav-item" href="https://awilkins.id.au/">
	<h1 class="title is-4" style="color: #666666; font-weight: bold">
	a<span style="color:#4a83d4; font-weight: bold">wilkins</span>.id.<span style="color:#4a83d4; font-weight: bold">au</span>
	</h1>
	</a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/axw">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/yayxw">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
          <a class="level-item" href="/index.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/gocov-llgo-update/">gocov, llgo update</a></h1>
      <div class="content">
        <p>I guess it&rsquo;s time for a quick update. I&rsquo;m not very diligent with this blogging thing; too busy having fun, programming. Sorry about that!<br /><br /><h3> Introducing gocov</h3>A couple of weeks ago I <a href="https://groups.google.com/d/topic/golang-nuts/abujHqfUbvo/discussion">announced </a><a href="http://github.com/axw/gocov">gocov</a>, a coverage testing tool for the Go programming language. I wrote gocov to quickly get an idea of how broadly tested packages are (namely exp/types, which I&rsquo;m working on in the background). The tool itself is written in Go, and works by source instrumentation/transformation. Currently gocov only does statement coverage.<br /><br />Using gocov is relatively simple (if I do say so myself). First, you install gocov by running:<br /><br /><pre style="background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); color: #333333; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 13px; line-height: 19px; margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;"><code style="background-color: transparent; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: none; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 12px; margin: 0px; padding: 0px;">go get github.com/axw/gocov/gocov</code></pre><br />This will install the gocov tool into your $GOPATH/bin directory. Once you have it installed, you can test a package (i.e. run its tests, and generate coverage data), by running:<br /><br /><pre style="background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); color: #333333; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 13px; line-height: 19px; margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;"><code style="background-color: transparent; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: none; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 12px; margin: 0px; padding: 0px;">gocov test &lt;path/to/package&gt;</code></pre><br />Under the covers, this will run &ldquo;go test &lt;path/to/package&gt;&rdquo;, after having gone through the process of instrumenting the source. Once the tests are complete, gocov will output the coverage information as a JSON structure to stdout. So you might want to pipe that output somewhere&hellip;<br /><br />Once you&rsquo;ve got the coverage information, you&rsquo;ll probably want to view it. So there are two other gocov commands: report, and annotate. The <i>report</i> command will generate a text report of the coverage of all the functions in the coverage information provided to it. For example:<br /><br /><pre style="background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); color: #333333; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 13px; line-height: 19px; margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;"><code style="background-color: transparent; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: none; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 12px; margin: 0px; padding: 0px;">gocov test github.com/axw/llgo/types | gocov report</code></pre><br />&hellip; will generate a report that looks something like:<br /><br /><pre style="background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;"><span style="color: #333333; font-family: 'Bitstream Vera Sans Mono', Courier, monospace;"><span style="font-size: 12px; line-height: 18px;">&hellip;<br />types/exportdata.go      readGopackHeader              69.23% (<sup>9</sup>&frasl;<sub>13</sub>)<br />types/gcimporter.go      gcParser.expect               66.67% (<sup>4</sup>&frasl;<sub>6</sub>)<br />types/gcimporter.go      gcParser.expectKeyword        66.67% (<sup>2</sup>&frasl;<sub>3</sub>)<br />&hellip;</span></span></pre>The <i>annotate</i>&nbsp;command will print out the source for a specified function, along with an annotation for each line that was missed. For example:<br /><br /><pre style="background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); color: #333333; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 13px; line-height: 19px; margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;"><code style="background-color: transparent; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: none; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 12px; margin: 0px; padding: 0px;">gocov test github.com/axw/llgo/types | gocov annotate - types.gcParser.expectKeyword</code></pre><br />&hellip; will output the following:<br /><br /><pre style="background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;"><span style="color: #333333; font-family: 'Bitstream Vera Sans Mono', Courier, monospace;"><span style="font-size: 12px; line-height: 18px;">266             func (p <em>gcParser) expectKeyword(keyword string) {<br />267                     lit := p.expect(scanner.Ident)<br />268                     if lit != keyword {<br />269 MISS                        p.errorf(&ldquo;expected keyword %s, got %q&rdquo;, keyword, lit)<br />270                     }<br />271             }</span></span></pre><br />As is often the case when I write software, I wrote gocov for my own needs; as such it&rsquo;s not terribly featureful, only doing what I&rsquo;ve needed thus far. If you would like to add a feature (maybe HTML output, or branch coverage), feel free to send a pull request on the <a href="http://github.com/axw/gocov">Github repository</a>, and I&rsquo;ll take a gander.<br /><br />Anyway, I hope it&rsquo;s of use to people. But not too many people, I don&rsquo;t have time to fix all of my crappy code! (Just kidding, I have no life.)<br /><br /><h3> Update on llgo: interface comparisons, exp/types</h3>I don&rsquo;t have a lot to report on this front, as I&rsquo;ve been doing various other things, like that stuff up there, but I can share a couple of bits of mildly interesting news.<br /><br />I&rsquo;ve been working a little on the runtime for llgo, and I&rsquo;m proud to say there&rsquo;s now an initial implementation of interface comparison in the runtime. This involved filling in the algorithm table for runtime types, implementing the runtime equality function (runtime.memequal), and implementing a runtime function (runtime.compareI2I) to extract and call it. It probably doesn&rsquo;t sound exciting when put like that, but this is something of a milestone.<br /><br />By the way, if you want to actually use the runtime, you can do it like this:<br /><br /><ol><li>Compile your program with llgo, storing the bitcode in file <i>x.ll</i>.</li><li>Compile llgo/runtime/</em>.go with llgo, storing the bitcode in file <i>y.ll</i>.</li><li>Link the two together, using llvm-link: <i>llvm-link -o z.ll x.ll y.ll</i></li></ol><div>And you&rsquo;re done. The resultant module, housed in&nbsp;<i>z.ll</i>, contains your program and the llgo runtime. Now you can concatenate strings and compare interfaces to your heart&rsquo;s content. Eventually llgo will contain an integrated linker, which will rewrite symbol names according to package paths.</div><div><i><br /></i></div><br />Finally, on exp/types: I submitted my first two CL&rsquo;s. Some of my ideas for exp/types were ill thought out, so the first was rejected (fairly), and the second needs some rework. I&rsquo;ll be writing up a design proposal document at some stage, to better document my rationale for changes. Anyway, I&rsquo;ll keep plugging away&hellip;<br /><br />Ade!<br /><br /></p>

      </div>
      <h2 class="subtitle is-6">
      Posted July 21, 2012.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/unit-testing-llgos-runtime/">Unit-testing llgo&#39;s runtime</a></h1>
      <div class="content">
        <p>It&rsquo;s been a while since I last wrote, primarily because I&rsquo;ve been moving house and was without Internet at home during the process. It&rsquo;s back now, but now I have Diablo III to contend with.<br /><br />In my <a href="http://blog.awilkins.id.au/2012/04/llgo-runtime-emerges.html">previous post</a> I mentioned that I would create a new branch for working on the <a href="http://github.com/axw/llgo">llgo </a>runtime. I haven&rsquo;t done that yet, though I haven&rsquo;t broken the build either. Rather, I&rsquo;ve introduced conditional compilation to <a href="http://github.com/axw/gollvm">gollvm </a>for builds against LLVM&rsquo;s trunk where unreleased functionality is required, e.g. LinkModules. This isn&rsquo;t currently being used in llgo-proper, so I&rsquo;ve gotten away without branching so far.<br /><br />The tag for building gollvm with unreleased functions is &ldquo;llvmsvn&rdquo;, so to build gollvm with LLVM&rsquo;s trunk, including the LinkModules function, do the following:<br /><pre style="background-color: #f8f8f8; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid rgb(204, 204, 204); color: #333333; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 13px; line-height: 19px; margin-bottom: 15px; margin-top: 15px; overflow: auto; padding: 6px 10px;"><code style="background-color: transparent; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: none; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 12px; margin: 0px; padding: 0px;">curl <a href="https://raw.github.com/axw/gollvm/master/install.sh">https://raw.github.com/axw/gollvm/master/install.sh</a> -tags llvmsvn | sh</code></pre>So I didn&rsquo;t break &ldquo;the build&rdquo;, meaning you can still build gollvm/llgo without also building LLVM from source. I did, however, break the llgo unit tests, as they are using the new LinkModules function. If you want to run the unit tests without building LLVM from source, then you can comment out the call to <i>llvm.LinkModules</i>&nbsp;in llgo/utils_test.go<i>; </i>of course, you should&nbsp;expect failures due to the runtime not being linked in, but that doesn&rsquo;t involve all tests.<br /><br />What else is new?<br /><ul><li><a href="https://groups.google.com/d/msg/golang-dev/aYZM61-ySUs/qVjKlt1WtWAJ">I announced on golang-dev a couple of weeks ago</a> that I intend to work on getting exp/types up to snuff. I&rsquo;ve moved some of the type construction code out of llgo-proper into llgo/types (a fork of exp/types), and eliminated most of the llgo-specific stuff from llgo/types. I&rsquo;ll need to set aside some time soon to learn how to use Mercurial and create some changelists.</li></ul><ul><li>A few weeks ago I started <a href="https://plus.google.com/u/0/102738380796586573408/posts/GibftVAePRW">playing with llgo and PNaCl</a>, to see how hard it would be to get something running in Chrome. It works (with the IR Translator/external sandbox anyway), but then llgo doesn&rsquo;t really do much at the moment.</li></ul><div>That&rsquo;s all for now.</div></p>

      </div>
      <h2 class="subtitle is-6">
      Posted June 3, 2012.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/an-llgo-runtime-emerges/">An llgo runtime emerges</a></h1>
      <div class="content">
        <p>It&rsquo;s been a long time coming, but I&rsquo;m now starting to put together pieces of the llgo runtime. Don&rsquo;t expect much any time soon, but I am zeroing in on a design at least.&nbsp;The sleuths in the crowd will find that only string concatenation has been implemented thus far, which is pretty boring. Next up, I hope, will be interface-to-interface conversions, and interface-to-value conversions, both of which require (for a sane implementation) a runtime library.<br /><br />I had previously intended to write the runtime largely in C, as I expected that would be the easiest route. I started down this road writing a basic thread creation routine using pthread, written in C. The code was compiled using <a href="http://clang.llvm.org/">Clang</a>, emitting LLVM IR which could be easily linked with the code generated by llgo. It&rsquo;s more or less the same idea implemented by the gc Go compiler (linking C and Go code, not relying on pthread). Even so, I&rsquo;d like to write the runtime in Go as much as possible.<br /><br />Why write the runtime in Go? Well for one, it will make llgo much more self contained, which will make distribution much easier since there won&rsquo;t be a reliance on Clang. Another reason is based on a lofty, but absolutely necessary goal: that llgo will one day be able to compile itself. If llgo compiles itself, and compiles its own runtime, then we have a great target for compiler optimisations: the compiler itself. In other words, <a href="http://prog21.dadgum.com/136.html">&ldquo;compiler optimisations should pay for themselves.&rdquo;</a><br /><br />In my last post I mentioned that LLVM 3.1 is coming up fast, and this release has the changes required by llgo. Unfortunately, I&rsquo;ve just found that the C API lacks an interface for linking modules, so I&rsquo;m going to have to submit a patch to LLVM again, and the window for inclusion in 3.1 has certainly passed. Rather than break gollvm/llgo&rsquo;s trunk again, I&rsquo;ll create a branch for work on the runtime. I&rsquo;ll post again when I&rsquo;ve submitted a patch to LLVM, assuming the minor addition is accepted.</p>

      </div>
      <h2 class="subtitle is-6">
      Posted April 28, 2012.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/llgo-update-go1-automated-tests/">llgo update: Go1, automated tests</a></h1>
      <div class="content">
        <p>This week I finished up&nbsp;<a href="http://www.udacity.com/overview/Course/cs373">Udacity CS373: Programming a Robotic Car</a>, and also <i>finally </i>finished reading <a href="http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach">GEB</a>. So I&rsquo;ll hopefully be able to commit some more time to llgo again.<br /><div><br /></div><div>I moved on to Go&rsquo;s weekly builds a while back, and updated both llgo and gollvm to conform. I&rsquo;m now on Go 1, as I hope most people are by now, and llgo is in good shape for Go 1 too. That&rsquo;s not to say that it compiles all of the Go 1 language, just that it runs in Go 1. Apart from that, I&rsquo;ve just been working through some sample programs to increase the compiler&rsquo;s capability.</div><div><br /></div><div>One of the things that I&rsquo;ve been a bit lazy about with llgo is automated testing, something I&rsquo;m usually pretty keen on. I&rsquo;ve grown anxious over regressions as time has gone on in the development, so I&rsquo;ve spent a little bit of time this week putting together an automated test suite, which I <a href="https://groups.google.com/d/topic/golang-nuts/s_EehtIclUY/discussion">mentioned in golang-nuts</a> a few days ago. The test suite doesn&rsquo;t cover a great deal yet, but it has picked up a couple of bugs already.</div><div><br /></div><div>One of the numerous things I like about Go is its well integrated tooling. For testing, Go provides the <a href="http://golang.org/pkg/testing">testing</a>&nbsp;package, and <a href="http://golang.org/cmd/go/#Test_packages">go test</a>&nbsp;tool. So you write your unit tests according to the specifications in the &ldquo;testing&rdquo; package, run &ldquo;go test&rdquo;, and your tests are all run. This is comparable to, say, Python, which has a similar &ldquo;unittest&rdquo; package. It is vastly more friendly than the various C++ unit test frameworks; that&rsquo;s in large part due to the way the Go language is designed, particularly with regard to how it fits into build systems and is parsed.</div><div><br /></div><div>In Go, everything you need to build a package is in the source (assuming you use the &ldquo;go&rdquo; command).</div><div><ul><li>The only external influences on the build process (environment variables GOOS, GOARCH, GOROOT, etc.) apply to the entire build procedure, not to single compilation units. Each variant will end up in a separate location when built: ${GOPATH}/pkg/${GOOS}_${GOARCH}/&lt;pkgname&gt;.</li><li>Platform-specific code is separated into multiple files (xxx_linux.go, xxx_windows.go, &hellip;), and they&rsquo;re automatically matched with the OS/architecture by the &ldquo;go&rdquo; command.</li><li>Package dependencies are automatically and unambiguously resolved. Compare this with C/C++ headers, which might come from anywhere in the preprocessor&rsquo;s include path.</li></ul><div>So anyway, back to llgo&rsquo;s testing. It works just like this: I&rsquo;ve created a separate program for each test case in the <span style="font-family: 'Courier New', Courier, monospace;">llgo/llgo/testdata</span>&nbsp;directory. Each of these programs corresponds to a test case written against the &ldquo;testing&rdquo; package, which does the following:</div></div><div><ol><li>Run the program using &ldquo;go run&rdquo;, and store the output.</li><li>Redirect stdout to a pipe, and run a goroutine to capture the output to a string.</li><li>Compile the program using llgo&rsquo;s Compile API, and then interpret the resultant bitcode using gollvm&rsquo;s ExecutionEngine API.</li><li>Restore the original stdout, and compare the output with that of the original &ldquo;go run&rdquo;.</li></ol><div>Pretty obvious I guess, but I was happy with how easy it was to do. Defer made the job of redirecting, restoring and closing file descriptors pain free; the go statement and channels made capturing and communicating the resulting data a cinch.</div></div><div><br /></div><div>This is getting a little ramble-ish, so I&rsquo;ll finish up. While testing, I discovered a problem with the way LLVM types are generated from <i>types.Type</i>&rsquo;s, which basically means that they need to be cached and reused, rather that generated afresh each time. At the same time I intend to remove all references to LLVM from my clone of the &ldquo;types&rdquo; package, and offer my updates back to the Go team. It&rsquo;s not fully functional yet, but there&rsquo;s at least a few gaps that I&rsquo;ve filled in.<br /><br />One last thing: LLVM 3.1 is due out May 14, so gollvm and llgo will no longer require LLVM from SVN. I really want to eliminate the dependency on llvm-config from the build of gollvm. I&rsquo;m considering a dlopen/dlsym shim and removing the cgo dependency on LLVM. I&rsquo;d be keen to hear some opinions, suggestions or alternatives.<br /><br />Until next time.</div></p>

      </div>
      <h2 class="subtitle is-6">
      Posted April 8, 2012.
      Tags:   <a href="/tags/go">go</a> ,  <a href="/tags/llgo">llgo</a> ,  <a href="/tags/gollvm">gollvm</a> ,  <a href="/tags/llvm">llvm</a>.
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/imports-in-llgo-jr./">Imports in llgo, jr.</a></h1>
      <div class="content">
        <p>So I realised I&rsquo;m a doofus the other day, when I started getting closer to completion on producing export metadata in llgo. Rolling my own import mechanism is unnecessary for now. Instead, I can just lean on the import mechanism that exists in the standard library (well, <a href="http://weekly.golang.org/doc/go1.html#exp">until Go 1</a> at least): go/types/GcImporter.<br /><br />I&rsquo;ve modified llgo to use go/ast/NewPackage, rather than the old code I had that was using go/parser/ParseFiles. The NewPackage function takes an optional &ldquo;importer&rdquo; object which will be used for inter-package dependency resolution, whereas ParseFiles does no resolution. The standard GcImporter type may be used to identify exports by interrogating the object and archive files in $GOROOT. The AST that&rsquo;s generated is filled in with external declarations, so it&rsquo;s then up to llgo to convert those into LLVM external declarations. Easy peasy.<br /><br />Now it&rsquo;s time to come up with a symbol naming scheme. Without having thought about it too hard, I&rsquo;m going to start off with the assumption that the absolute name of the symbol (package+name), with slashes converted to dots, will do the trick. Once I&rsquo;ve implemented that, I&rsquo;ll need to start work on the runtime in earnest. It&rsquo;s also high time I put some automated tests in place, since things are starting to get a little stabler.<br /><br />In the long term I&rsquo;ll probably want to continue on with my original plan, which is to generate module-level metadata in the LLVM bitcode, and then extract this in a custom importer. It should be quite straightforward.&nbsp;Earlier this week I wrapped up some updates to gollvm to add an API to make generating <a href="http://llvm.org/docs/SourceLevelDebugging.html">source-level debugging metadata</a> simpler. This will be useful not only for describing exports, but also for what it&rsquo;s intended: generating <a href="http://dwarfstd.org/">DWARF</a>&nbsp;debug information.<br /><br />In other news: my wife just ordered the 1-4a box set of&nbsp;<a href="http://www-cs-staff.stanford.edu/~uno/taocp.html">The Art of Computer Programming</a>&nbsp;for me. At the moment I am slowly making way through&nbsp;<a href="http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach">Gödel, Escher, Bach: an Eternal Golden Braid</a>, and so far, so good. Looking forward to more light reading for the bus/train!</p>

      </div>
      <h2 class="subtitle is-6">
      Posted February 19, 2012.
      Tags:   <a href="/tags/go">go</a> ,  <a href="/tags/llgo">llgo</a> ,  <a href="/tags/gollvm">gollvm</a> ,  <a href="/tags/llvm">llvm</a>.
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/llgo-back-in-business/">llgo: back in business</a></h1>
      <div class="content">
        <p>I&rsquo;ve been hacking away on llgo, on evenings and weekends when I&rsquo;ve had the chance. It&rsquo;s now roughly equivalent in functionality to where it was before I upgraded LLVM to trunk (3.1) and broke everything. There&rsquo;s a couple of added bonuses too, like proper arbitrary precision constants, and partial support for untyped constants.<br /><br />Now that the basics are working again, I&rsquo;ll get back to working on the import/export mechanism. I expect this will expose more design flaws, and will take a while. I still plan to make use of debug metadata, which I am not altogether familiar with. I&rsquo;ll also need to decide how the linker and the runtime library are going to work.<br /><br />In other news, I&rsquo;ve moved <a href="http://github.com/axw/pushy">Pushy</a>&nbsp;to GitHub. I&rsquo;m not actively developing it at the moment, but I wanted to consolidate the services I&rsquo;m consuming. I do have an addition to the Java API in the works: a sort of remote classloader, that will communicate over a Pushy connection to fetch classes/resources. The idea is to make it really quick and easy to run a bit of Java code on a remote machine, without having to deploy the application remotely. I&rsquo;ll hopefully get around to pushing this change within the coming few weeks.</p>

      </div>
      <h2 class="subtitle is-6">
      Posted February 11, 2012.
      Tags:   <a href="/tags/go">go</a> ,  <a href="/tags/llgo">llgo</a> ,  <a href="/tags/llvm">llvm</a> ,  <a href="/tags/pushy">pushy</a>.
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/cmonster-0.2-released/">cmonster 0.2 released</a></h1>
      <div class="content">
        <p>Last week I announced a new version of cmonster (now version 0.2) <a href="http://lists.cs.uiuc.edu/pipermail/cfe-dev/2012-January/019362.html">on the Clang mailing list</a>.&nbsp;I&rsquo;ve finally updated the <a href="https://github.com/axw/cmonster/">Github page for cmonster</a> with some basic examples, and installation instructions.<br /><br />I&nbsp;asked on the Clang mailing list for some feedback, but so far all I&rsquo;m hearing is crickets. I&rsquo;m surprised that nobody&rsquo;s interested enough to reply, but I&rsquo;ll freely admit that I&rsquo;m not particularly good at marketing. If you do check it out, let me know what I can do to make it useful for you.<br /><br />In other news: I haven&rsquo;t spent much time on llgo recently, what with Real Life happening all the time. I sent a patch into LLVM to add improved support for named metadata, which was accepted. I also made a bunch of fixes to gollvm so that it builds and works with LLVM 3.0 (and some additional changes to work with trunk).<br /><br />There&rsquo;s been some changes to LLVM that mean I can no longer abuse the metadata system by attaching metadata to values. Metadata can now be specified only on instructions. This means that I can no longer attach type information to values using metadata, nor identify function receivers in a similar way. So llgo will need to maintain type and receiver (amongst other) information outside of LLVM&rsquo;s values. This was always going to be necessary, I&rsquo;d just been putting it off to get something that worked.<br /><br />I hope to get back to making inroad with llgo soon. I feel like I made pretty good progress on implementing my crazy ideas in 2011. Here&rsquo;s hoping 2012 works out as well.</p>

      </div>
      <h2 class="subtitle is-6">
      Posted January 7, 2012.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/imports-in-llgo/">Imports in llgo</a></h1>
      <div class="content">
        <p>It&rsquo;s been a while. I&rsquo;ve implemented bits and pieces of the Go language: constants (though not properly handling arbitrary precision numbers at this stage), structs, functions (with and without receivers, as declarations and as literals), and goroutines. Much of the implementation is simplistic, not covering all bases. I want to get something vaguely useful working before I go down the path to completeness.<br /><br />I intended to wait until I had something interesting to show off, but unfortunately I&rsquo;ve hit a snag with LLVM.<br /><br />Debug information might sound luxurious, but it&rsquo;s how I&rsquo;m intending to encode information about exported symbols, so I can implement imports. The <a href="http://golang.org/cmd/gc/">gc compiler</a>&nbsp;creates a header in archives that lists all of this information. LLVM provides a standard set of <a href="http://llvm.org/docs/SourceLevelDebugging.html">metadata for describing debug information</a>, using DWARF descriptors.<br /><br />So I figured I could build on the LLVM metadata, extending it to describe Go-specific information where necessary. The benefit here, aside from reusing an existing well-defined format, is that I&rsquo;d get DWARF debugging information in my output binaries, something I&rsquo;d eventually want anyway. Unfortunately it appears that there&rsquo;s no C API for generating named metadata.<br /><br />I&rsquo;ll have a look at extending the LLVM C API now. Down the rabbit hole&hellip;<br /><br /><b>Update - 7 January 2012</b><br />I submitted a <span id="goog_2124873712"></span>patch to LLVM to add support for adding named metadata to a module, <a href="http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20111219/133770.html">which has been accepted</a><span id="goog_2124873713"></span>. This will, presumably, be part of LLVM 3.1.<br /><br /></p>

      </div>
      <h2 class="subtitle is-6">
      Posted December 3, 2011.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/writing-a-compiler-or-learning-a-language-the-hard-way-part-deux/">Writing a Compiler, or Learning a Language the Hard Way (Part Deux)</a></h1>
      <div class="content">
        <div>A couple of weeks ago <a href="http://blog.awilkins.id.au/2011/10/writing-compiler-or-learning-language.html">I wrote</a> that I would be attempting to write a Go compiler using the LLVM compiler infrastructure. The blog post got a bit of attention after being linked on <a href="http://lamernews.com/">Lamer News</a>&nbsp;(and a bit more attention than intended!), so I guess there's at least a couple of people out there interested in hearing whether anything comes of this effort.</div><div><br /></div><div>I've been a mixture of sick and busy (maybe a little bit slack?), but this weekend I finally found some time to put into my shiny new Go compiler. Yesterday I buffed the corners of what I had written so far, and pushed it to github. Behold, <a href="http://github.com/axw/llgo">llgo</a>!&nbsp;llgo&nbsp;does not currently compile much of the language, and it only compiles completely standalone programs (imports aren't handled). I'll be adding in features as I get time, but this is largely an educational endeavour for me, so I'm not really in a rush.</div><div><br /></div><div>Let's look briefly at how it's put together. llgo is written in Go, and uses the standard Go parser/ast packages. For code generation, the <a href="http://github.com/axw/gollvm">gollvm</a> (Go bindings for LLVM) package is used. So it's just a matter of calling the parser to generate an AST, then walking the AST and generating LLVM instructions. The latter part is what I'm most new to, and I'm just starting to get to grips with LLVM and&nbsp;<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a>&nbsp;(Single Static Assignment), and their nuances. It's mostly pretty straightforward though.</div><div><br /></div><div style="text-align: center;"><b>Forward, ho!</b></div><div><br /></div><div>There's plenty of things to implement, but there's a bunch of big ticket items that I'm particularly interested in solving. They are, in no particular order:</div><div><ul><li>Imports.</li><li>Interfaces.</li><li>Goroutines and channels.</li><li>Deferred function calls.</li><li>Closures.</li><li><a href="http://golang.org/cmd/cgo">cgo</a></li><li>Garbage Collection</li></ul></div><div><br /></div><div><b>Imports</b></div><div><br /></div><div>If you were to attempt to compile a program with llgo - "Hello, World!", say - then I'm sure you'd find one giant gaping hole in the lack of support for imports. So you wouldn't be able to import <i>fmt </i>and do <i>fmt.Println</i>. Actually I have implemented the <i>println </i>builtin, but that's beside the point. The module system is pretty fundamental, so I'll have to address this soon.</div><div><br /></div><div>The picture I have in my head is that each package will compile to (ideally) machine-independent LLVM bitcode libraries, which will go somewhere in the $GOROOT/pkg hierarchy. Just as Go examines archives to determine what they export, so llgo will load and examine the modules defined by the bitcode.<br /><br />Somewhat related to imports is the runtime. I dare say that most of the imports people will ever do will be importing standard libraries, which will at some time or another use the Go runtime (e.g. reflection, and string comparisons, system calls). So I'll have to start thinking seriously about which parts of the runtime I'll be able be able to reuse, and which parts I'll rewrite.<br /><br /><b>Interfaces</b><br /><b><br /></b><br />In my previous blog post I talked about the idea of pseudo duck-typing in a statically compiled language ("implicit interfaces"), so this feature has a special place in my heart. I have some ideas of how to implement them, but I'll have to implement user-defined types first.</div><div><br /></div><div><b>Goroutines and Channels</b></div><div><b><br /></b></div><div>I'm not going for efficiency at this stage, I'm just going for functionality. So I intend, initially, to implement goroutines 1-1 with respect to threads. The&nbsp;<i>gc </i>compiler/runtime&nbsp;does M-N with a preemptive application-level scheduler; I think gccgo still does 1-1. I also do not intend, initially at least, to implement split stacks.&nbsp;These things can well be considered functionality, especially since the language intends to make creating many goroutines inexpensive and efficient. I have to prioritise, though, so I'll tackle efficiency and scalability later.<br /><br />I've implemented channel-like data structures in C++ before, so I don't expect that to be too difficult. I'll just start out with a simple mutex/condition-based data structure, with or without an underlying FIFO array/queue depending on whether or not the channel is buffered.</div><div><b><br /></b></div><div><b>Deferred Function Calls</b></div><div><b><br /></b></div><div>As a general rule, I'm trying to do this... not clean room, but not just by copying what's done in gc/gccgo either. After all, I'm trying to teach myself something here, and I find doing things is a great way of learning for me. Sometimes things go awry, but then I know what not do next time. It also serves as a good background when reading about how others have solved the problem.<br /><br />Russ Cox wrote an interesting article on <a href="http://research.swtch.com/2010/03/broken-abstractions-in-go.html">how deferred function calls are implemented in Go</a>. Actually the article was nominally about how breaking abstractions can be a good thing, and I tend to agree. LLVM adds another level of abstraction, which means some of these functions don't end up being quite as efficient as when they're implemented directly in assembler or machine code.</div><div><b><br /></b></div><div><b>Closures</b></div><div><b><br /></b></div><div>If you're not familiar with this term, it's essentially a function that has captured some variables in its defining environment. In Go you can define <i>function literals</i>, which are anonymous functions. If a function literal refers to a variable defined in the outer scope, then the function will be defined as a closure.</div><div><br /></div><div>I had been wondering about how I would go about implementing closures in llgo. I was thinking, broadly, that I would need to store the variables in memory alongside the function code. How would I do this in LLVM? I could treat closures differently, representing them as a structure containing the captured variables, and a pointer to the function, which would need to have additional arguments defined to accept the captured variables. Then the caller of the closure would have to treat it differently to a simple function. This seems a bit ugly, so I wondered, how does gc do it?</div><div><br /></div><div>The gc implementation is very elegant: it allocates memory on the heap, with PROT_EXEC enabled, and stores dynamically generated machine code in it. At the end of the code, the captured variables are stored. The machine code loads the variables from memory onto the stack for use in the closure. Elegant, but how can we do that in LLVM?</div><div><br /></div><div>LLVM abstracts away the details of the underlying target system, which means you deal with an intermediate representation of instructions rather than machine-specific instructions. We could dynamically generate code using LLVM, but that would mean requiring LLVM in every program, which seems a bit heavyweight. Or we could just reuse the code from gc, since it's pretty well contained, but that means adding in platform-specifics where there were none before. I think that's a better solution, but I might have to see what other LLVM-based compilers have done. I guess the Glasgow Haskell Compiler might be a good first place to look.</div><div><b><br /></b></div><div><b>cgo</b></div><div><b><br /></b></div><div>This one has the potential to be quite interesting. There's already a mature LLVM-based C compiler: <a href="http://clang.llvm.org/">clang</a>. So llgo could potentially leverage it to implement a cgo equivalent. Both clang and llgo will emit bitcode; llgo (or the cgo equivalent) will analyse the bitcode emitted from clang, and determine the available functions and types.</div><div><br /><b>Garbage Collection</b><br /><b><br /></b><br />I know conceptually how mark &amp; sweep algorithms work, but I have never implemented one, nor even analysed an implementation. <a href="http://llvm.org/docs/GarbageCollection.html">LLVM provides some support for garbage collection</a>, which will presumably make things easier.<br /><br /><div style="text-align: center;"><b>Over and Out</b></div><div style="text-align: left;"><b><br /></b></div><div style="text-align: left;">Rather than continuing to talk about doing stuff, I'm going to go and do stuff. If you're interested in following my progress, I suggest that you watch <a href="https://github.com/axw/llgo">llgo on github</a>.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Without further ado, adieu.</div></div>

      </div>
      <h2 class="subtitle is-6">
      Posted November 7, 2011.
      
      </h2>
    </article>
    
    <article>
      <h1 class="title"><a href="https://awilkins.id.au/post/blogger/writing-a-compiler-or-learning-a-language-the-hard-way/">Writing a Compiler, or Learning a Language the Hard Way</a></h1>
      <div class="content">
        <p>For a while now I&rsquo;ve been lamenting the lack of progress in systems programming languages. I work primarily in C++ (professionally, anyway), a language which leaves a lot to be desired. The end result, assuming you know what you&rsquo;re doing, is likely to be fast code. But getting there can be a tedious and precarious journey. Don&rsquo;t get me wrong, I&rsquo;m not a C++ hater. I just think we can do better.<br /><br />So for the past few I&rsquo;ve been&nbsp;storing away ideas for writing my own language. (<i>Groan,&nbsp;another one</i>.) The vast majority of languages these days seem to be JVM based, or some other VM such as the CLR. This is fine for many applications, but for a lot of systems programming you typically want to be much closer to the hardware. What I want is something with the ease and rapidity of development of, say, Python, with the power of a lower-level language such as C/C++.<br /><br /><b><span class="Apple-style-span" style="font-size: large;"><br /></span></b><br /><b><span class="Apple-style-span" style="font-size: large;">The Easy: Ideas</span></b><br /><br />So what are those ideas I&rsquo;d stored away then? Well to be honest, many of them boil down to syntactic sugar (syntactic caramel?), so here are the more functional ones:<br /><br /><ul><li><b>Implicit Interfaces</b>. The idea is that classes should be able to implement an interface without explicitly saying so, just by implementing the methods defined in the interface. Poor-man&rsquo;s duck-typing if you will.</li><li><b>Link Time Optimisation (LTO)</b> should be the norm. Say you write a function in a library which does everything and the kitchen sink. If the calling program only uses a function from your library in a certain way, then the function should be optimised for that usage.</li><li><b>Pure Functions.</b>&nbsp;This kind of fits under LTO. I want simpler meta-programming: it should be possible to mark functions as being &ldquo;pure&rdquo;, which means (in my terminology) that the function either has no side-effects, or affects only temporary variables. Calls to these functions could then be evaluated at compile time, e.g. to calculate complex mathematical expressions. I guess this just comes under &ldquo;fancy optimiser&rdquo;?</li><li><b>Pattern Matching.</b>&nbsp;I haven&rsquo;t really fleshed this one out, but I think it would be handy to be able to match functions not just based on signature, but based on the values of the arguments.</li><li><b>No preprocessor, no headers. </b>When code is distributed, the modules should be self describing, such as with Java&rsquo;s compiled .class files. This would eliminate problems such as compiling against an old version of an interface, and linking against a new, incompatible implementation.</li><li><b>For the love of God, no garbage collection.</b>&nbsp;What can I say? I like my <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>.</li><li>I&rsquo;m not really sure what title to give this one, but I wanted to eliminate the problems you get with linking objects together that have been compiled with different options in C++ (e.g. with/out RTTI, exceptions, or perhaps against an entirely different STL/standard library.)</li></ul>There were some other requirements I had in mind, such as having a single reference implementation&nbsp;à&nbsp;la CPython, and including a parser with the runtime to simplify tool development.<br /><div><br /></div><div><b><span class="Apple-style-span" style="font-size: large;"><br /></span></b></div><div><b><span class="Apple-style-span" style="font-size: large;">The Hard: Writing a Compiler</span></b></div><div><b><span class="Apple-style-span" style="font-size: large;"><br /></span></b></div><div>Anyone can come up with ideas. Even coming up with practical ideas isn&rsquo;t too hard, but implementing them is something else altogether. Especially so for someone like me who has had no formal education in compilers, or language design/implementation. Hell, my university course didn&rsquo;t even cover formal grammars or parsing. I&rsquo;ve picked some things up by myself, but it&rsquo;s a very academic field.</div><div><br /></div><div>Back when I was in uni, I toyed around with&nbsp;<a href="http://www.cminusminus.org/">C&ndash;</a>, which at the time looked like quite a promising &ldquo;portable assembly language&rdquo;. This language is (or at least was) used as the intermediate language for the <a href="http://www.haskell.org/ghc/">Glasgow Haskell Compiler</a>. My self-taught knowledge of language design/implementation and code generation were not really up to scratch, so I didn&rsquo;t get much further than writing toy languages.</div><div><br /></div><div>Fast forward a few years, and I&rsquo;ve got the itch to implement a compiler again. I&rsquo;ve recently been playing around with LLVM. It boasts a relatively easy to use API, which takes out some of the drudgery of writing the &ldquo;bitcode&rdquo; (an intermediate code that can be translated to machine code). I&rsquo;ve got a bit more knowledge and programming skill behind my belt now, so let&rsquo;s get to work on that language, right!?</div><div><br /></div><div>I read something recently which is summarised as: learn intimately that which you wish to replace. Now I don&rsquo;t have any illusions of replacing any existing language, but I think the message is still relevant. I&rsquo;ve never implemented a language OR a compiler before, and now I&rsquo;m going to both at once? How about I make this a bit easier on myself, and write a compiler for an existing language. If I still want to implement my own language later, I can use the experience I gained.</div><div><br /></div><div>I&rsquo;ve been looking for an excuse for a while now to learn the&nbsp;<a href="http://www.golang.org/">Go Programming Language</a>. It has some of the same design goals as my hypothetical language, so it seemed like a good fit.</div><div><br /></div><div><br /></div><div><span class="Apple-style-span" style="font-size: large;"><b>The Fun: Learning Go and LLVM</b></span></div><div><span class="Apple-style-span" style="font-size: large;"><b><br /></b></span></div><div>I&rsquo;ve been learning Go in my precious spare time for the last couple of weeks. There&rsquo;s a nifty web-app which provides an interactive tutorial in Go, called <a href="http://go-tour.appspot.com/">A Tour of Go</a>. It&rsquo;s a bit of fun, and I recommend it to anyone wanting to learn the language.</div><div><br /></div><div>So anyway, I&rsquo;m now playing around with writing a Go compiler using LLVM. Why?</div><div><ul><li>To learn LLVM, and more generally how to write a compiler and generate code.</li><li>To learn Go.</li><li>Potentially to fill a gap in JIT compilation of Go programs.</li><li>Why not?</li></ul><div>Writing the compiler will be made much easier by the fact that the Go runtime includes a Go parser, and someone has already implemented <a href="https://github.com/nsf/gollvm">Go bindings for LLVM</a>. I haven&rsquo;t made a great deal of progress yet, but it seems achievable. When I&rsquo;ve got something vaguely useful, I&rsquo;ll chuck it over on GitHub.</div></div><div><br /></div><div>If you know anything about Go, you&rsquo;ll probably have noticed that at least one of the ideas that I presented above is present in Go: implicit interfaces. I really can&rsquo;t say whether this concept is new or not - it&rsquo;s probably not - but I did at least come up with it independently. Just sayin&rsquo;!</div><div><br /></div><div>I&rsquo;ll write a follow-up post when I get some time, describing a bit more about the Go compiler, the challenges I&rsquo;ve come across, and my thoughts on how to solve them.&nbsp;</div></p>

      </div>
      <h2 class="subtitle is-6">
      Posted October 23, 2011.
      
      </h2>
    </article>
    
  </div>
</section>

<section class="section">
  <div class="container">
    <nav class="level is-mobile">
      <div class="level-left">
        <div class="level-item">
          
          <a class="button" href="/post/">
            <span class="icon is-small is-marginless">
              <i class="fa fa-angle-left"></i>
            </span>
            Newer
          </a>
          
        </div>
      </div>
      <div class="level-right is-marginless">
        <div class="level-item">
          
          <a class="button" href="/post/page/3/">
            Older
            <span class="icon is-small is-marginless">
              <i class="fa fa-angle-right"></i>
            </span>
          </a>
          
        </div>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container has-text-centered">
    <p></p>
  </div>
</section>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/go.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/python.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-17223840-3', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>



