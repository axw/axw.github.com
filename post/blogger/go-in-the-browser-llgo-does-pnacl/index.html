<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Go in the Browser: llgo does PNaCl | awilkins.id.au</title>
<link rel="stylesheet" href="https://awilkins.id.au//css/style.css">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/github.min.css">


<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
	
	<a class="nav-item" href="https://awilkins.id.au/">
	<h1 class="title is-4" style="color: #666666; font-weight: bold">
	a<span style="color:#4a83d4; font-weight: bold">wilkins</span>.id.<span style="color:#4a83d4; font-weight: bold">au</span>
	</h1>
	</a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/axw">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/yayxw">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
          <a class="level-item" href="/index.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    <h2 class="subtitle is-6">December 9, 2012</h2>
    <h1 class="title">Go in the Browser: llgo does PNaCl</h1>
    <div class="content">
      <p><br /><div style="margin-bottom: 0cm;">Last week I briefly <a href="https://plus.google.com/102738380796586573408/posts/HdvvfFqMvig">reported on Google+</a> that I had written a Go-based <a href="https://developers.google.com/native-client/">Native Client module</a>, built it with llgo, and successfully loaded it into Google Chrome. I&rsquo;d like to expand on this a little now, and describe how to build and run it.</div><div style="margin-bottom: 0cm;"><br /></div><h3><b>Before your start&hellip;</b></h3><div style="margin-bottom: 0cm;">If you want to want to try this out yourself, then you&rsquo;ll need to grab yourself a copy of the <a href="https://developers.google.com/native-client/sdk/download">Native Client SDK</a>. I&rsquo;ve only tested this on Ubuntu Linux 12.10 (x86-64), so if you&rsquo;re trying this out on a different OS/arch you may need to alter the instructions.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">Anyway, grab the SDK according to the instructions on the page I linked to above. Be sure to get the&nbsp;devevelopment/unstable branch, by updating with the &ldquo;pepper_canary&rdquo; target:</div><div style="margin-bottom: 0cm; margin-left: 1.25cm;">$ cd nacl_sdk; ./naclsdk update pepper_canary</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">This is not a small download, so go and brew some tea, or just read on to see where we&rsquo;re going with this.</div><div style="margin-bottom: 0cm;"><br /></div><h3><b>The anatomy of a PNaCl module</b></h3><div style="margin-bottom: 0cm;"><span style="background-position: initial initial; background-repeat: initial initial;">By now I guess you probably know what</span><span style="background-position: initial initial; background-repeat: initial initial;">Native Client is, </span><span style="background-position: initial initial; background-repeat: initial initial;">but if you don&rsquo;t, I suggest you take a moment to read about it on the Google Developers (<a href="https://developers.google.com/native-client/">https://developers.google.com/native-client/</a>) site.</span><span style="background-position: initial initial; background-repeat: initial initial;"></span>What may not be so well known is PNaCl, the next evolution of Native Client. PNaCl (pronounced pinnacle), is short for <i>Portable</i><i>Native Client, </i>and is based on LLVM.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">Developers continue to write their code the same as in traditional NaCl, but now it is compiled to LLVM <i>bitcode; </i>PNaCl restricts usage to a portable subset of bitcode so that it can then be translated to native x86, x86-64, or ARM machine code. To compile C or C++ modules to PNaCl/LLVM bitcode, one uses the pnacl-clang compiler provided with the Native Client SDK.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">To make use of Native Client, one develops a <i>module</i>, which is an executable, that can be loaded into Google Chrome (or Chromium). A module implements certain functions specified in the Pepper API (<i>PPAPI</i>), which is the API that interfaces your module with the browser. One of the functions is <i>PPP_InitializeModule</i>, and another is <i>PPP_GetInterface</i>. The former provides a function pointer to the module for calling back into the browser; the latter is invoked to interrogate the module for <i>i</i><i>nterfaces</i>that it implements.</div><div style="margin-bottom: 0cm;"><br /></div><h3><b>A<i></i><i>nacl/</i><i>ppapi</i> package for Go</b></h3><div style="margin-bottom: 0cm;">Since llgo speaks LLVM, it should be feasible to write PNaCl modules in Go, right? Right! So I set about doing this last week, and found that it was fairly easy to do. I have written a demo module which you can find here: <a href="https://github.com/axw/llgo/tree/master/pkg/nacl/ppapi">https://github.com/axw/llgo/tree/master/pkg/nacl/ppapi</a>, which I later intend to morph into a reusable Go package, with a proper API. I have made a lot of shortcuts, and the code is not particularly idiomatic Go; bear in mind that llgo is still quite immature, and that this is mostly a proof of concept.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">Most of the code in the package is scaffolding; the example module is mostly defined in <i><a href="https://github.com/axw/llgo/blob/master/llgo/testdata/programs/nacl/example.go">example.go</a></i>, some also in <i><a href="https://github.com/axw/llgo/blob/master/pkg/nacl/ppapi/ppapi.go">ppapi.go</a></i>. At the top of example.go, we instantiate a pppInstance1_1, which is a structure which defines the “Instance” interface. This interface is used to communicate the lifecycle of an instance of the module; when a module is loaded in a web page, then this interface is invoked. We care about when a module instance is created, and when it is attached to a <i>view</i> (i.e. the area of the page which contains the module). Note that when I say interface, I mean a PPAPI interface, not a Go interface. Later, I hope to have modules implement Go interfaces, and hide the translation to PPAPI interfaces.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">The example is contrived, and quite simple; it demonstrates the use of the <a href="https://developers.google.com/native-client/pepperc/struct_p_p_b___graphics2_d__1__0">Graphics2D</a> interface, which, as the name suggests, enables a module to perform 2D graphics operations. The demo simply draws repeating rectangles of different colours, animated by regularly updating the graphics context and shifting the pixels on each iteration. I would have used the standard “image” Go package, but unfortunately llgo is currently having trouble compiling it. I&rsquo;ll look into that soon.</div><div style="margin-bottom: 0cm;"><br /></div><h3><b>Building llgo</b></h3><div style="margin-bottom: 0cm;"><span style="background-position: initial initial; background-repeat: initial initial;">Alright</span>, how do we build this thing? We&rsquo;re going to do the following things:</div><ol><li><div style="margin-bottom: 0cm;">Build llgo,  and related tools.</div></li><li><div style="margin-bottom: 0cm;">Compile the  PNaCl-module Go code into an LLVM module.</div></li><li><div style="margin-bottom: 0cm;">Link the llgo  runtime into the module.</div></li><li><div style="margin-bottom: 0cm;">Link the  ppapi library from the Native Client SDK into the module.</div></li><li><div style="margin-bottom: 0cm;">Translate the  module into a native executable.*</div></li></ol><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"><em>The final step is currently necessary, but eventually Chrome/Chromium will perform the translation in the browser.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">Let&rsquo;s begin by building the <i>llgo-dist</i>tool. This will be used to build the llgo compiler, runtime, and linker. More on each of those in a moment. Go ahead and build llgo-dist:</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><i>$ go get github.com/axw/llgo/cmd/llgo-dist</i></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">The llgo-dist tool takes two options: <i>-llvm-config, </i>and <i>-triple</i>. The former is the path to the <i>llvm-config</i>tool, and defaults to simply “llvm-config” (i.e. find it using PATH). The latter is the LLVM target triple used for compiling the runtime package (and other core packages, like syscall). The Native Client SDK contains an llvm-config and the shared library that we need to link with to use LLVM&rsquo;s C API.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">As I said above, I&rsquo;m running on Linux x86-64, so for my case, the llvm-config tool can be found in:</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><i>$ nacl_sdk/pepper_canary/toolchain/linux_x86_pnacl/host_x86<em>64/bin/llvm-config</i></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">At this point, you should put the “host</em>&lt;arch&gt;/bin” directory in your PATH, and the “host_&lt;arch&gt;/lib” directory in your LD_LIBRARY_PATH, as llgo currently requires it, and I refer <span style="background-position: initial initial; background-repeat: initial initial;">to executables without their full paths </span><span style="background-position: initial initial; background-repeat: initial initial;">in some cases</span><span style="background-position: initial initial; background-repeat: initial initial;">.</span></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">The Native Client SDK creates shared libraries with the target <i>armv7-none-linux-gnueabi</i>, so we&rsquo;ll do the same. Let&rsquo;s go ahead and build llgo now.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><i>$ llgo-dist -triple=armv7-none-linux-gnueabi -llvm-config=nacl_sdk/pepper_canary/toolchain/linux_x86_pnacl/host_x86_64/bin/llvm-config</i></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">We now have a compiler, linker, and runtime. As an aside, on my laptop it took about 2.5s to build, which is great! The gc toolchain is a wonderful thing. You can safely ignore the warning about “different data layouts” when llgo-dist compiles the syscall package, as we will not be using the syscall package in our example.</div><div style="margin-bottom: 0cm;"><br /></div><h3><b>Building the example</b></h3><div style="margin-bottom: 0cm;">Now, let&rsquo;s compile the PNaCl module:</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><i>$ llgo -c -o main.o -triple=armv7-none-linux-gnueabi llgo/pkg/nacl/ppapi/</em>.go llgo/testdata/programs/nacl/example.go</i></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">This creates a file called “main.o”, which contains the LLVM bitcode for the module. Next, we&rsquo;ll link in the runtime. Eventually, I hope that the “go” tool will be able to support llgo (I have hacked mine up to do this), but for now you&rsquo;re going to have to do this manually.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><i>$ llgo-link -o main.o main.o $GOPATH/pkg/llgo/armv7-none-linux-gnueabi/runtime.a</i></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">Now we have a module with the runtime linked in. The llgo runtime defines things like functions for appending to slices, manipulating maps, etc. Later, it will contain a more sophisticated memory allocator, a garbage collector runtime, and a goroutine scheduler.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">We can&rsquo;t translate this to a native executable yet, because it lacks an entry point. In a PNaCl module, the entry point is defined in a shared library called <i>libppapi_stub.a,</i><i></i>which is included by the libppapi.a linker script<i>. </i>We can link this in using pnacl-clang, like so:</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><i>$ pnacl-clang -o main.pexe main.o -lppapi</i></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">This creates a <i>portable executable</i> (.pexe), an executable still in LLVM bitcode form. As I mentioned earlier, this will eventually be the finished product, ready to load into Chrome/Chromium. For now, we need to run a final step to create the native machine code executable:</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><i>$ pnacl-translate -arch x86-64 -o main_x86_64.nexe main.pexe</i></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">That&rsquo;s it. If you want to load this in an x86 or ARM system, you&rsquo;ll also need to translate the pexe to an x86 and/or ARM nexe. Now we can run it.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"></div><h3><b>Loading the PNaCl module into Chrome</b></h3><div style="margin-bottom: 0cm;">I&rsquo;m not sure at what point all the necessary parts became available in Chrome/Chromium, so I&rsquo;ll just say what I&rsquo;m running: I have added the Google Chrome PPA, and installed google-chrome-beta. This is currently at version 24.0.1312.35 beta.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">By default, Chrome only allows Native Client modules to load from the Chrome Web Store, but you can override this by mucking about in about:flags. Load up Chrome, go to about:flags, enable “Native Client”, and restart Chrome so the change takes effect. Curiously, there&rsquo;s a “Portable Native Client” flag; it may be that the translator is already inside Chrome, but I&rsquo;m not aware of how to use it.</div><div style="margin-bottom: 0cm;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-N9-czi_nYd0/UMQWw9TEGLI/AAAAAAAACgQ/MMSbKuSrcsE/s1600/about_flags.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="183" src="http://4.bp.blogspot.com/-N9-czi_nYd0/UMQWw9TEGLI/AAAAAAAACgQ/MMSbKuSrcsE/s320/about_flags.png" width="320" /></a></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">To simplify matters, I&rsquo;m going to hijack the hello_world example in the Native Client SDK. If you want to start from scratch, refer to the Native Client SDK documentation. So anyway we&rsquo;ll build the hello_world example, then replace the executable with our own one.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;">$ cd nacl_sdk/examples/hello_world</div><div style="margin-bottom: 0cm; margin-left: 1.25cm;">$ make pnacl/Release/hello_world.nmf</div><div style="margin-bottom: 0cm; margin-left: 1.25cm;">$ cp &lt;path/to/<i>main_x86_64.nexe</i><i>&gt; pnacl/Release/hello_world_x86_64.nexe</i></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><br /></div><div style="margin-bottom: 0cm;">Now start an HTTP server to serve this application (inside the hello_world directory):</div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><br /></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;">$ python -m SimpleHTTPServer</div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><i>Serving HTTP on 0.0.0.0 port 8000 &hellip;</i></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">Finally, navigate to the following location:</div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><a href="http://localhost:8000/index_pnacl_Release.html">http://localhost:8000/index_pnacl_Release.html</a></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-AUXuC0SqrEM/UMQOCol6U8I/AAAAAAAACgA/HB7Gh3UAEjI/s1600/go_pnacl.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="281" src="http://2.bp.blogspot.com/-AUXuC0SqrEM/UMQOCol6U8I/AAAAAAAACgA/HB7Gh3UAEjI/s320/go_pnacl.png" width="320" /></a></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"><br /></div><div style="margin-bottom: 0cm; margin-left: 1.25cm;"></div><div style="margin-bottom: 0cm;">Behold, animated bars! Obviously the example is awfully simplistic, but the I wanted to get this out so others can start playing with it. I&rsquo;m not really in the business of fancy graphics, so I&rsquo;ll leave more impressive demos to others.</div><div style="margin-bottom: 0cm;"><br /></div><h3><b>Next Steps</b></h3><div style="margin-bottom: 0cm;">I&rsquo;ll keep dabbling with this, but my more immediate goals are to complete llgo&rsquo;s general functionality. As wonderful as all of this is, it&rsquo;s no good if the compiler doesn&rsquo;t work correctly. Anyway, once I do get some more time for this, I intend to:</div><ul><li><div style="margin-bottom: 0cm;">Clean  up nacl/ppapi, providing  an  external API.</div></li><li><div style="margin-bottom: 0cm;">Update llgo-link to transform a “main” function into a global  constructor (i.e. an “init” function) when compiling for PNaCl.</div></li><li><div style="margin-bottom: 0cm;">Update  llgo-link to link in libppapi_stub.a when compiling for PNaCl, so we  don&rsquo;t need to use pnacl-clang. Ideally  we should be able to “go build”, and have that immediately ready  to be loaded into Chrome.</div></li><li><div style="margin-bottom: 0cm;">Get  the  image  package to build, and  update nacl/ppapi to use  it.</div></li><li><div style="margin-bottom: 0cm;">Implement  syscall  for PNaCl.  This  will probably involve calling standard POSIX C functions, like <i>read</i>,  <i>write, mmap, </i>etc.  Native Client code is heavily sandboxed, but  provides familiar POSIX APIs  to  do things like file I/O.</div></li></ul><div style="margin-bottom: 0cm;">If you play around with this and produce something interesting, please let me know.</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">That&rsquo;s all for now – have fun!</div><br /><br /></p>

    </div>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p></p>
  </div>
</section>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/go.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/python.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-17223840-3', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>



